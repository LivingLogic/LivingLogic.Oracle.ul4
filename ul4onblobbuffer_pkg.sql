create or replace package UL4ONBLOBBUFFER_PKG
as
	/******************************************************************************\
	UL4ON is a lightweight text-based crossplatform data interchange format.

	As the name suggests its purpose is to transport the object types supported by
	UL4. For more info about UL4 see `http://python.livinglogic.de/UL4.html` and for
	more info about UL4ON see `http://python.livinglogic.de/UL4ON.html`.

	`ul4onblobbuffer_pkg` can be used for creating UL4ON dumps iteratively. For
	example creating an UL4ON dump of a list with two strings can be done like this:

	```
	declare
		v_ul4on ul4onblobbuffer_pkg.state;
		v_output blob;
	begin
		ul4onblobbuffer_pkg.init(v_ul4on);
		ul4onblobbuffer_pkg.beginlist(v_ul4on);
			ul4onblobbuffer_pkg.str(v_ul4on, 'foo');
			ul4onblobbuffer_pkg.str(v_ul4on, 'bar');
		ul4onblobbuffer_pkg.endlist(v_ul4on);
		ul4onblobbuffer_pkg.getoutput(v_ul4on, v_output);
	end;
	```

	The BLOB `v_output` generated by this will contain `l s"foo" s"bar" ]`.
	Any implementation of UL4ON will be able to deserialize this dump back into
	the original string list.
	\******************************************************************************/

	/*
	The key length for the `backrefregistry` must be long enough for all keys
	that are used in an UL4ON dump. These include:

	-	Primary keys of records (which means `varchar2(30)` in all cases).
	-	`control.ctl_id` || '.' || `lookup.lup_kennung` (used for
		`de.livinglogic.livingapi.lookupitem` objects, i.e. records from `lookup`).
	-	`tablename || '/' || primarykeyvalue || '/' || fieldname` (used for
		`de.livinglogic.livingapi.file`, i.e. records from `upload`).

	1000 should be enough for all of those cases (although `lookup.lup_kennung` is
	longer).
	*/
	type backrefregistry is table of integer index by varchar2(1000 char);

	-- State that remembers which objects we've already dumped
	type state is record(
		-- The `BLOB` where the UL4ON dump is collected
		output blob,
		-- Buffered output (since we don't want to append single characters to a `CLOB`)
		buffer varchar2(32767 char),
		-- Length of `v_buffer`
		buffer_len integer,
		-- Maps strings of the form `type:pkvalue` to the index location where we've dumped the object
		registry backrefregistry,
		-- The next unused index (i.e. the size of the registry)
		nextindex integer
	);

	-- Initialized some internal buffers and variables (must be called before any other procedures)
	procedure init(p_state in out nocopy state);

	-- Flush all internal buffers (must be call before the `BLOB` value `output` is used/returned)
	procedure flush(p_state in out nocopy state);

	-- Frees all internal output buffers (including `output`, so it should have been copied first)
	procedure clear_output(p_state in out nocopy state);

	-- Frees all internal buffers (like `clear_output()`) and the backref registry.
	procedure clear_all(p_state in out nocopy state);

	-- Register that an object with the specified key will be output at the current position/index.
	-- Normally this is used only internally, but is public to enable syncing the UL4ON codec state
	-- between the client and the server.
	procedure register(p_state in out nocopy state, p_key varchar2);

	-- Methods for outputting various objects into the UL4ON dump
	procedure none(p_state in out nocopy state);
	procedure bool(p_state in out nocopy state, p_value in integer);
	procedure int(p_state in out nocopy state, p_value in integer);
	procedure float(p_state in out nocopy state, p_value in number);
	procedure color(p_state in out nocopy state, p_red in integer, p_green in integer, p_blue in integer, p_alpha in integer);
	procedure color(p_state in out nocopy state, p_rgba32 in integer);
	procedure date_(p_state in out nocopy state, p_value date);
	procedure datetime(p_state in out nocopy state, p_value date);
	procedure datetime(p_state in out nocopy state, p_value timestamp);
	procedure timedelta(p_state in out nocopy state, p_days integer := 0, p_seconds integer := 0, p_microseconds integer := 0);
	procedure monthdelta(p_state in out nocopy state, p_months integer := 0);
	procedure slice(p_state in out nocopy state, p_start integer := null, p_stop integer := null);
	procedure str(p_state in out nocopy state, p_value in varchar2, p_backref boolean := false);
	procedure str(p_state in out nocopy state, p_value in clob);
	procedure template(
		p_state in out nocopy state,
		p_name varchar2,
		p_source in clob,
		p_signature varchar2 := null,
		p_whitespace varchar2 := 'keep'
	);

	-- Method for outputting a string key (simply calls `str()` with `p_backref=true`)
	procedure key(p_state in out nocopy state, p_key in varchar2);

	-- Methods for outputting key/value pairs inside a dictionary
	procedure keynone(p_state in out nocopy state, p_key in varchar2);
	procedure keybool(p_state in out nocopy state, p_key in varchar2, p_value in integer);
	procedure keyint(p_state in out nocopy state, p_key in varchar2, p_value in integer);
	procedure keyfloat(p_state in out nocopy state, p_key in varchar2, p_value in number);
	procedure keycolor(p_state in out nocopy state, p_key in varchar2, p_red in integer, p_green in integer, p_blue in integer, p_alpha in integer);
	procedure keycolor(p_state in out nocopy state, p_key in varchar2, p_rgba32 in integer);
	procedure keydatetime(p_state in out nocopy state, p_key in varchar2, p_value date);
	procedure keydatetime(p_state in out nocopy state, p_key in varchar2, p_value timestamp);
	procedure keytimedelta(p_state in out nocopy state, p_key in varchar2, p_days integer := 0, p_seconds integer := 0, p_microseconds integer := 0);
	procedure keymonthdelta(p_state in out nocopy state, p_key in varchar2, p_months integer := 0);
	procedure keyslice(p_state in out nocopy state, p_key in varchar2, p_start integer := null, p_stop integer := null);
	procedure keystr(p_state in out nocopy state, p_key in varchar2, p_value in varchar2, p_backref boolean := false);
	procedure keystr(p_state in out nocopy state, p_key in varchar2, p_value in clob);

	-- Begin and end a list object
	procedure beginlist(p_state in out nocopy state);
	procedure endlist(p_state in out nocopy state);

	-- Begin and end a set object
	procedure beginset(p_state in out nocopy state);
	procedure endset(p_state in out nocopy state);

	-- Begin and end a dict object
	procedure begindict(p_state in out nocopy state, p_ordered integer := 0);
	procedure enddict(p_state in out nocopy state);

	-- Begin, test for and end a custom object
	procedure beginobject(p_state in out nocopy state, p_type varchar2);
	function needobject(p_state in out nocopy state, p_table in varchar2, p_pk in varchar2) return boolean;
	procedure beginobject(p_state in out nocopy state, p_type in varchar2, p_id in varchar2, p_table in varchar2, p_pk in varchar2);
	procedure endobject(p_state in out nocopy state);

	-- Forget an object that might already have been output
	-- (e.g. when it has been deleted or changed
	procedure forgetobject(p_state in out nocopy state, p_table in varchar2, p_pk in varchar2);

	-- Return the current size of the output blob
	function outputsize(p_state in out nocopy state) return integer;

	-- Get the current output
	procedure getoutput(p_state in out nocopy state, p_output in out nocopy blob);
end;

/

create or replace package body UL4ONBLOBBUFFER_PKG
as
	v_state state;

	procedure init(p_state in out nocopy state)
	as
	begin
		p_state.output := null;
		p_state.registry.delete;
		p_state.nextindex := 0;
		p_state.buffer := null;
		p_state.buffer_len := 0;
	end;

	procedure flush(p_state in out nocopy state)
	as
	begin
		if p_state.output is null then
			dbms_lob.createtemporary(p_state.output, true);
		end if;
		dbms_lob.append(p_state.output, utl_raw.cast_to_raw(p_state.buffer));
		p_state.buffer := null;
		p_state.buffer_len := 0;
	end;

	procedure clear_output(p_state in out nocopy state)
	as
	begin
		p_state.output := null;
		p_state.buffer := null;
		p_state.buffer_len := 0;
	end;

	procedure clear_all(p_state in out nocopy state)
	as
	begin
		clear_output(p_state);
		p_state.nextindex := 0;
		p_state.registry.delete;
	end;

	procedure register(p_state in out nocopy state, p_key varchar2)
	as
	begin
		p_state.registry(p_key) := p_state.nextindex;
		p_state.nextindex := p_state.nextindex + 1;
	end;

	procedure write(p_state in out nocopy state, p_value in varchar2)
	as
		v_addlen integer;
	begin
		-- Initialize package state, if it hasn't been initialized yet
		if p_state.nextindex is null then
			init(p_state);
		end if;
		v_addlen := lengthb(p_value);
		if p_state.buffer_len + v_addlen >= 32767 then
			flush(p_state);
		end if;
		p_state.buffer := p_state.buffer || p_value;
		p_state.buffer_len := p_state.buffer_len + v_addlen;
	end;

	procedure pad(p_state in out nocopy state)
	as
	begin
		if p_state.output is not null or p_state.buffer_len != 0 then
			write(p_state, ' ');
		end if;
	end;

	procedure none(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, 'n');
	end;

	procedure bool(p_state in out nocopy state, p_value in integer)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		elsif p_value != 0 then
			write(p_state, 'bT');
		else
			write(p_state, 'bF');
		end if;
	end;

	procedure int(p_state in out nocopy state, p_value in integer)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		else
			write(p_state, 'i');
			write(p_state, to_char(p_value));
		end if;
	end;

	procedure float(p_state in out nocopy state, p_value in number)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		else
			write(p_state, 'f');
			write(p_state, trim(to_char(p_value, '999999999999999999999999999999.9999999999')));
		end if;
	end;

	procedure color(p_state in out nocopy state, p_red in integer, p_green in integer, p_blue in integer, p_alpha in integer)
	as
	begin
		pad(p_state);
		write(p_state, 'c');
		int(p_state, p_red);
		int(p_state, p_green);
		int(p_state, p_blue);
		int(p_state, p_alpha);
	end;

	procedure color(p_state in out nocopy state, p_rgba32 in integer)
	as
	begin
		if p_rgba32 is null then
			none(p_state);
		else
			color(
				p_state,
				mod(floor(p_rgba32/(256*256*256)), 256),
				mod(floor(p_rgba32/(256*256)), 256),
				mod(floor(p_rgba32/256), 256),
				mod(floor(p_rgba32), 256)
			);
		end if;
	end;

	procedure timedelta(p_state in out nocopy state, p_days integer := 0, p_seconds integer := 0, p_microseconds integer := 0)
	as
	begin
		pad(p_state);
		write(p_state, 't');
		int(p_state, p_days);
		int(p_state, p_seconds);
		int(p_state, p_microseconds);
	end;

	procedure monthdelta(p_state in out nocopy state, p_months integer := 0)
	as
	begin
		pad(p_state);
		write(p_state, 'm');
		int(p_state, p_months);
	end;

	procedure date_(p_state in out nocopy state, p_value date)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		else
			write(p_state, 'x');
			int(p_state, extract(year from p_value));
			int(p_state, extract(month from p_value));
			int(p_state, extract(day from p_value));
		end if;
	end;

	procedure datetime(p_state in out nocopy state, p_value date)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		else
			write(p_state, 'z');
			int(p_state, extract(year from p_value));
			int(p_state, extract(month from p_value));
			int(p_state, extract(day from p_value));
			int(p_state, to_number(to_char(p_value, 'HH24')));
			int(p_state, to_number(to_char(p_value, 'MI')));
			int(p_state, to_number(to_char(p_value, 'SS')));
			int(p_state, 0);
		end if;
	end;

	procedure datetime(p_state in out nocopy state, p_value timestamp)
	as
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		else
			write(p_state, 'z');
			int(p_state, extract(year from p_value));
			int(p_state, extract(month from p_value));
			int(p_state, extract(day from p_value));
			int(p_state, extract(hour from p_value));
			int(p_state, extract(minute from p_value));
			int(p_state, trunc(extract(second from p_value)));
			int(p_state, to_number(to_char(p_value, 'FF6')));
		end if;
	end;

	procedure slice(p_state in out nocopy state, p_start integer := null, p_stop integer := null)
	as
	begin
		pad(p_state);
		write(p_state, 'r');
		int(p_state, p_start);
		int(p_state, p_stop);
	end;

	procedure writeul4onstr(p_state in out nocopy state, p_value in varchar2)
	as
	begin
		if p_state.output is null then
			dbms_lob.createtemporary(p_state.output, true);
		end if;
		if length(p_value) <= 16000 then
			write(p_state, replace(replace(p_value, '\', '\\'), '"', '\"'));
		else
			for i in 0 .. trunc((length(p_value) - 1)/16000) loop
				write(p_state, replace(replace(substr(p_value, i * 16000 + 1, 16000), '\', '\\'), '"', '\"'));
			end loop;
		end if;
	end;

	procedure str(p_state in out nocopy state, p_value in varchar2, p_backref boolean := false)
	as
		v_regkey varchar2(300 char);
	begin
		pad(p_state);
		if p_value is null then
			write(p_state, 'n');
		elsif p_backref and length(p_value) < 300-4 then -- the key must fit in the backrefregistry, so we refuse to store long strings in the registry
			v_regkey := 'str:' || p_value;
			if p_state.registry.exists(v_regkey) then
				write(p_state, '^');
				write(p_state, to_char(p_state.registry(v_regkey)));
			else
				write(p_state, 'S"');
				writeul4onstr(p_state, p_value);
				write(p_state, '"');
				register(p_state, v_regkey);
			end if;
		else
			write(p_state, 's"');
			writeul4onstr(p_state, p_value);
			write(p_state, '"');
		end if;
	end;

	procedure str(p_state in out nocopy state, p_value in clob)
	as
		v_buf varchar2(16000 char);
	begin
		pad(p_state);
		if p_value is null or dbms_lob.getlength(p_value) = 0 then
			write(p_state, 'n');
		else
			write(p_state, 's"');

			for i in 0 .. trunc((dbms_lob.getlength(p_value) - 1 )/16000) loop
				v_buf := dbms_lob.substr(p_value, 16000, i * 16000 + 1);
				writeul4onstr(p_state, v_buf);
			end loop;

			write(p_state, '"');
		end if;
	end;

	procedure template(
		p_state in out nocopy state,
		p_name varchar2,
		p_source in clob,
		p_signature varchar2 := null,
		p_whitespace varchar2 := 'keep'
	)
	as
	begin
		beginobject(p_state, 'de.livinglogic.ul4.template');
			none(p_state); -- The version ``None`` means that the template must be compiled from source
			str(p_state, p_name);
			str(p_state, p_source);
			str(p_state, p_signature);
			str(p_state, p_whitespace);
		endobject(p_state);
	end;

	procedure template(
		p_name varchar2,
		p_source in clob,
		p_signature varchar2 := null,
		p_whitespace varchar2 := 'keep'
	)
	as
	begin
		template(
			v_state,
			p_name,
			p_source,
			p_signature,
			p_whitespace
		);
	end;

	procedure key(p_state in out nocopy state, p_key in varchar2)
	as
	begin
		str(p_state, p_key, true);
	end;

	procedure keynone(p_state in out nocopy state, p_key in varchar2)
	as
	begin
		key(p_state, p_key);
		none(p_state);
	end;

	procedure keybool(p_state in out nocopy state, p_key in varchar2, p_value in integer)
	as
	begin
		key(p_state, p_key);
		bool(p_state, p_value);
	end;

	procedure keyint(p_state in out nocopy state, p_key in varchar2, p_value in integer)
	as
	begin
		key(p_state, p_key);
		int(p_state, p_value);
	end;

	procedure keyfloat(p_state in out nocopy state, p_key in varchar2, p_value in number)
	as
	begin
		key(p_state, p_key);
		float(p_state, p_value);
	end;

	procedure keydatetime(p_state in out nocopy state, p_key in varchar2, p_value date)
	as
	begin
		key(p_state, p_key);
		datetime(p_state, p_value);
	end;

	procedure keydatetime(p_state in out nocopy state, p_key in varchar2, p_value timestamp)
	as
	begin
		key(p_state, p_key);
		datetime(p_state, p_value);
	end;

	procedure keytimedelta(p_state in out nocopy state, p_key in varchar2, p_days integer := 0, p_seconds integer := 0, p_microseconds integer := 0)
	as
	begin
		key(p_state, p_key);
		timedelta(p_state, p_days, p_seconds, p_microseconds);
	end;

	procedure keymonthdelta(p_state in out nocopy state, p_key in varchar2, p_months integer := 0)
	as
	begin
		key(p_state, p_key);
		monthdelta(p_state, p_months);
	end;

	procedure keyslice(p_state in out nocopy state, p_key in varchar2, p_start integer := null, p_stop integer := null)
	as
	begin
		key(p_state, p_key);
		slice(p_state, p_start, p_stop);
	end;

	procedure keycolor(p_state in out nocopy state, p_key in varchar2, p_red in integer, p_green in integer, p_blue in integer, p_alpha in integer)
	as
	begin
		key(p_state, p_key);
		color(p_state, p_red, p_green, p_blue, p_alpha);
	end;

	procedure keycolor(p_state in out nocopy state, p_key in varchar2, p_rgba32 in integer)
	as
	begin
		key(p_state, p_key);
		color(p_state, p_rgba32);
	end;

	procedure keystr(p_state in out nocopy state, p_key in varchar2, p_value in varchar2, p_backref boolean := false)
	as
	begin
		key(p_state, p_key);
		str(p_state, p_value, p_backref);
	end;

	procedure keystr(p_state in out nocopy state, p_key in varchar2, p_value in clob)
	as
	begin
		key(p_state, p_key);
		str(p_state, p_value);
	end;

	procedure beginlist(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, 'l');
	end;

	procedure endlist(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, ']');
	end;

	procedure beginset(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, 'y');
	end;

	procedure endset(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, '}');
	end;

	procedure begindict(p_state in out nocopy state, p_ordered integer := 0)
	as
	begin
		pad(p_state);
		write(p_state, case when p_ordered = 0 then 'd' else 'e' end);
	end;

	procedure enddict(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, '}');
	end;

	procedure beginobject(p_state in out nocopy state, p_type varchar2)
	as
	begin
		pad(p_state);
		write(p_state, 'o');
		str(p_state, p_type);
	end;

	function needobject(p_state in out nocopy state, p_table in varchar2, p_pk in varchar2)
	return boolean
	as
	begin
		if p_pk is null then
			none(p_state);
			return false;
		else
			if p_state.registry.exists(p_table || ':' || p_pk) then
				pad(p_state);
				write(p_state, '^');
				write(p_state, to_char(p_state.registry(p_table || ':' || p_pk)));
				return false;
			else
				return true;
			end if;
		end if;
	end;

	procedure beginobject(p_state in out nocopy state, p_type in varchar2, p_id in varchar2, p_table in varchar2, p_pk in varchar2)
	as
	begin
		pad(p_state);
		write(p_state, 'P');
		register(p_state, p_table || ':' || p_pk);
		str(p_state, p_type, true);
		str(p_state, p_id, true);
	end;

	procedure endobject(p_state in out nocopy state)
	as
	begin
		pad(p_state);
		write(p_state, ')');
	end;

	procedure forgetobject(p_state in out nocopy state, p_table in varchar2, p_pk in varchar2)
	as
	begin
		p_state.registry.delete(p_table || ':' || p_pk);
	end;

	function outputsize(p_state in out nocopy state)
	return integer
	as
	begin
		if p_state.output is null then
			return 0;
		else
			return length(p_state.output);
		end if;
	end;

	procedure getoutput(p_state in out nocopy state, p_output in out nocopy blob)
	as
	begin
		flush(p_state);
		p_output := p_state.output;
	end;
end;

/

