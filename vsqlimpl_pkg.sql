create or replace package VSQLIMPL_PKG
as
	/******************************************************************************\
	This package contains all the functions that will be called from PL/SQL code
	generated by `vsql_pkg.vsql_foracle`/`vsql_pkg.bool_foracle`.
	\******************************************************************************/

	/******************************************************************************\
	The following functions implement the vSQL equility operator `==` for various
	argument types.
	\******************************************************************************/
	function eq_int_int(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function eq_int_number(p_value1 in integer, p_value2 in number) return integer deterministic;
	function eq_number_int(p_value1 in number, p_value2 in integer) return integer deterministic;
	function eq_number_number(p_value1 in number, p_value2 in number) return integer deterministic;
	function eq_datetime_datetime(p_value1 in date, p_value2 in date) return integer deterministic;
	function eq_datetimedelta_datetimedelta(p_value1 in number, p_value2 in number) return integer deterministic;
	function eq_str_str(p_value1 in varchar2, p_value2 in varchar2) return integer deterministic;
	function eq_str_clob(p_value1 in varchar2, p_value2 in clob) return integer deterministic;
	function eq_clob_str(p_value1 in clob, p_value2 in varchar2) return integer deterministic;
	function eq_clob_clob(p_value1 in clob, p_value2 in clob) return integer deterministic;
	function eq_intlist_intlist(p_value1 in integers, p_value2 in integers) return integer deterministic;
	function eq_intlist_numberlist(p_value1 in integers, p_value2 in numbers) return integer deterministic;
	function eq_numberlist_intlist(p_value1 in numbers, p_value2 in integers) return integer deterministic;
	function eq_numberlist_numberlist(p_value1 in numbers, p_value2 in numbers) return integer deterministic;
	function eq_strlist_strlist(p_value1 in varchars, p_value2 in varchars) return integer deterministic;
	function eq_strlist_cloblist(p_value1 in varchars, p_value2 in clobs) return integer deterministic;
	function eq_cloblist_strlist(p_value1 in clobs, p_value2 in varchars) return integer deterministic;
	function eq_cloblist_cloblist(p_value1 in clobs, p_value2 in clobs) return integer deterministic;
	function eq_datetimelist_datetimelist(p_value1 in dates, p_value2 in dates) return integer deterministic;
	function eq_nulllist_nulllist(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function eq_nulllist_intlist(p_value1 in integer, p_value2 in integers) return integer deterministic;
	function eq_nulllist_numberlist(p_value1 in integer, p_value2 in numbers) return integer deterministic;
	function eq_nulllist_strlist(p_value1 in integer, p_value2 in varchars) return integer deterministic;
	function eq_nulllist_cloblist(p_value1 in integer, p_value2 in clobs) return integer deterministic;
	function eq_nulllist_datetimelist(p_value1 in integer, p_value2 in dates) return integer deterministic;
	function eq_intlist_nulllist(p_value1 in integers, p_value2 in integer) return integer deterministic;
	function eq_numberlist_nulllist(p_value1 in numbers, p_value2 in integer) return integer deterministic;
	function eq_strlist_nulllist(p_value1 in varchars, p_value2 in integer) return integer deterministic;
	function eq_cloblist_nulllist(p_value1 in clobs, p_value2 in integer) return integer deterministic;
	function eq_datetimelist_nulllist(p_value1 in dates, p_value2 in integer) return integer deterministic;
	function eq_intset_intset(p_value1 in integers, p_value2 in integers) return integer deterministic;
	function eq_numberset_numberset(p_value1 in numbers, p_value2 in numbers) return integer deterministic;
	function eq_strset_strset(p_value1 in varchars, p_value2 in varchars) return integer deterministic;
	function eq_datetimeset_datetimeset(p_value1 in dates, p_value2 in dates) return integer deterministic;
	function eq_nullset_nullset(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function eq_nullset_intset(p_value1 in integer, p_value2 in integers) return integer deterministic;
	function eq_nullset_numberset(p_value1 in integer, p_value2 in numbers) return integer deterministic;
	function eq_nullset_strset(p_value1 in integer, p_value2 in varchars) return integer deterministic;
	function eq_nullset_datetimeset(p_value1 in integer, p_value2 in dates) return integer deterministic;
	function eq_intset_nullset(p_value1 in integers, p_value2 in integer) return integer deterministic;
	function eq_numberset_nullset(p_value1 in numbers, p_value2 in integer) return integer deterministic;
	function eq_strset_nullset(p_value1 in varchars, p_value2 in integer) return integer deterministic;
	function eq_datetimeset_nullset(p_value1 in dates, p_value2 in integer) return integer deterministic;

	/******************************************************************************\
	We don't need to implemnt inequality comparison, as we can fall bcak to the equiality comparison.
	\******************************************************************************/

	/******************************************************************************\
	Helper functions for the comparison operators for comparing various argument
	types.
	\******************************************************************************/
	function cmp_int_int(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function cmp_int_number(p_value1 in integer, p_value2 in number) return integer deterministic;
	function cmp_number_int(p_value1 in number, p_value2 in integer) return integer deterministic;
	function cmp_number_number(p_value1 in number, p_value2 in number) return integer deterministic;
	function cmp_datetime_datetime(p_value1 in date, p_value2 in date) return integer deterministic;
	function cmp_str_str(p_value1 in varchar2, p_value2 in varchar2) return integer deterministic;
	function cmp_str_clob(p_value1 in varchar2, p_value2 in clob) return integer deterministic;
	function cmp_clob_str(p_value1 in clob, p_value2 in varchar2) return integer deterministic;
	function cmp_clob_clob(p_value1 in clob, p_value2 in clob) return integer deterministic;
	function cmp_intlist_intlist(p_value1 in integers, p_value2 in integers) return integer deterministic;
	function cmp_intlist_numberlist(p_value1 in integers, p_value2 in numbers) return integer deterministic;
	function cmp_numberlist_intlist(p_value1 in numbers, p_value2 in integers) return integer deterministic;
	function cmp_numberlist_numberlist(p_value1 in numbers, p_value2 in numbers) return integer deterministic;
	function cmp_strlist_strlist(p_value1 in varchars, p_value2 in varchars) return integer deterministic;
	function cmp_strlist_cloblist(p_value1 in varchars, p_value2 in clobs) return integer deterministic;
	function cmp_cloblist_strlist(p_value1 in clobs, p_value2 in varchars) return integer deterministic;
	function cmp_cloblist_cloblist(p_value1 in clobs, p_value2 in clobs) return integer deterministic;
	function cmp_datetimelist_datetimelist(p_value1 in dates, p_value2 in dates) return integer deterministic;
	function cmp_nulllist_nulllist(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function cmp_nulllist_intlist(p_value1 in integer, p_value2 in integers) return integer deterministic;
	function cmp_nulllist_numberlist(p_value1 in integer, p_value2 in numbers) return integer deterministic;
	function cmp_nulllist_strlist(p_value1 in integer, p_value2 in varchars) return integer deterministic;
	function cmp_nulllist_cloblist(p_value1 in integer, p_value2 in clobs) return integer deterministic;
	function cmp_nulllist_datetimelist(p_value1 in integer, p_value2 in dates) return integer deterministic;
	function cmp_intlist_nulllist(p_value1 in integers, p_value2 in integer) return integer deterministic;
	function cmp_numberlist_nulllist(p_value1 in numbers, p_value2 in integer) return integer deterministic;
	function cmp_strlist_nulllist(p_value1 in varchars, p_value2 in integer) return integer deterministic;
	function cmp_cloblist_nulllist(p_value1 in clobs, p_value2 in integer) return integer deterministic;
	function cmp_datetimelist_nulllist(p_value1 in dates, p_value2 in integer) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL addition operator `+` for various
	argument types.
	\******************************************************************************/
	function add_intlist_intlist(p_list1 in integers, p_list2 in integers) return integers deterministic;
	function add_intlist_numberlist(p_list1 in integers, p_list2 in numbers) return numbers deterministic;
	function add_numberlist_intlist(p_list1 in numbers, p_list2 in integers) return numbers deterministic;
	function add_numberlist_numberlist(p_list1 in numbers, p_list2 in numbers) return numbers deterministic;
	function add_strlist_strlist(p_list1 in varchars, p_list2 in varchars) return varchars deterministic;
	function add_strlist_cloblist(p_list1 in varchars, p_list2 in clobs) return clobs deterministic;
	function add_cloblist_strlist(p_list1 in clobs, p_list2 in varchars) return clobs deterministic;
	function add_cloblist_cloblist(p_list1 in clobs, p_list2 in clobs) return clobs deterministic;
	function add_datetimelist_datetimelist(p_list1 in dates, p_list2 in dates) return dates deterministic;
	function add_nulllist_intlist(p_list1 in integer, p_list2 in integers) return integers deterministic;
	function add_nulllist_numberlist(p_list1 in integer, p_list2 in numbers) return numbers deterministic;
	function add_nulllist_strlist(p_list1 in integer, p_list2 in varchars) return varchars deterministic;
	function add_nulllist_cloblist(p_list1 in integer, p_list2 in clobs) return clobs deterministic;
	function add_nulllist_datetimelist(p_list1 in integer, p_list2 in dates) return dates deterministic;
	function add_intlist_nulllist(p_list1 in integers, p_list2 in integer) return integers deterministic;
	function add_numberlist_nulllist(p_list1 in numbers, p_list2 in integer) return numbers deterministic;
	function add_strlist_nulllist(p_list1 in varchars, p_list2 in integer) return varchars deterministic;
	function add_cloblist_nulllist(p_list1 in clobs, p_list2 in integer) return clobs deterministic;
	function add_datetimelist_nulllist(p_list1 in dates, p_list2 in integer) return dates deterministic;
	function add_datetime_months(p_date in date, p_months in integer) return date deterministic;
	function add_months_datetime(p_months in integer, p_date in date) return date deterministic;

	/******************************************************************************\
	The following functions implement the vSQL multiplication operator `*` for
	various argument types.
	\******************************************************************************/
	function mul_int_str(p_arg1 in integer, p_arg2 in varchar2) return varchar2 deterministic;
	function mul_int_clob(p_arg1 in integer, p_arg2 in clob) return clob deterministic;
	function mul_int_intlist(p_arg1 in integer, p_arg2 in integers) return integers deterministic;
	function mul_int_numberlist(p_arg1 in integer, p_arg2 in numbers) return numbers deterministic;
	function mul_int_datetimelist(p_arg1 in integer, p_arg2 in dates) return dates deterministic;
	function mul_int_strlist(p_arg1 in integer, p_arg2 in varchars) return varchars deterministic;
	function mul_int_cloblist(p_arg1 in integer, p_arg2 in clobs) return clobs deterministic;
	function mul_str_int(p_arg1 in varchar2, p_arg2 in integer) return varchar2 deterministic;
	function mul_clob_int(p_arg1 in clob, p_arg2 in integer) return clob deterministic;
	function mul_intlist_int(p_arg1 in integers, p_arg2 in integer) return integers deterministic;
	function mul_numberlist_int(p_arg1 in numbers, p_arg2 in integer) return numbers deterministic;
	function mul_datetimelist_int(p_arg1 in dates, p_arg2 in integer) return dates deterministic;
	function mul_strlist_int(p_arg1 in varchars, p_arg2 in integer) return varchars deterministic;
	function mul_cloblist_int(p_arg1 in clobs, p_arg2 in integer) return clobs deterministic;

	/******************************************************************************\
	The following functions implement the vSQL truncating division operator `//`
	for various argument types.
	\******************************************************************************/
	function floordiv_int_int(p_arg1 in integer, p_arg2 in integer) return integer deterministic;
	function floordiv_int_number(p_arg1 in integer, p_arg2 in number) return number deterministic;
	function floordiv_number_int(p_arg1 in number, p_arg2 in integer) return number deterministic;
	function floordiv_number_number(p_arg1 in number, p_arg2 in number) return number deterministic;

	/******************************************************************************\
	The following functions implement the vSQL modulo operator `%` for various
	argument types.
	\******************************************************************************/
	function mod_int_int(p_arg1 in integer, p_arg2 in integer) return integer deterministic;
	function mod_int_number(p_arg1 in integer, p_arg2 in number) return number deterministic;
	function mod_number_int(p_arg1 in number, p_arg2 in integer) return number deterministic;
	function mod_number_number(p_arg1 in number, p_arg2 in number) return number deterministic;
	function mod_color_color(p_color1 integer, p_color2 integer) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL containment test (`x in y`) for
	various argument types.

	There are no functions for the "inverted containment test", as the SQL
	generated for it will be `1 - contains_...`.
	\******************************************************************************/
	function contains_str_str(p_needle in varchar2, p_haystack in varchar2)	return integer deterministic;
	function contains_str_clob(p_needle in varchar2, p_haystack in clob)	return integer deterministic;
	function contains_null_nulllist(p_haystack in integer) return integer deterministic;
	function contains_null_intlist(p_haystack in integers) return integer deterministic;
	function contains_null_numberlist(p_haystack in numbers) return integer deterministic;
	function contains_null_strlist(p_haystack in varchars) return integer deterministic;
	function contains_null_cloblist(p_haystack in clobs) return integer deterministic;
	function contains_null_datetimelist(p_haystack in dates) return integer deterministic;
	function contains_int_intlist(p_needle in integer, p_haystack in integers) return integer deterministic;
	function contains_int_numberlist(p_needle in integer, p_haystack in numbers) return integer deterministic;
	function contains_number_intlist(p_needle in number, p_haystack in integers) return integer deterministic;
	function contains_number_numberlist(p_needle in number, p_haystack in numbers) return integer deterministic;
	function contains_str_strlist(p_needle in varchar2, p_haystack in varchars) return integer deterministic;
	function contains_str_cloblist(p_needle in varchar2, p_haystack in clobs) return integer deterministic;
	function contains_clob_strlist(p_needle in clob, p_haystack in varchars) return integer deterministic;
	function contains_clob_cloblist(p_needle in clob, p_haystack in clobs) return integer deterministic;
	function contains_datetime_datetimelist(p_needle in date, p_haystack in dates) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL item operator (`x[y]`) for various
	argument types.
	\******************************************************************************/
	function item_str(p_str in varchar2, p_index in integer) return varchar2 deterministic;
	function item_clob(p_str in clob, p_index in integer) return varchar2 deterministic;
	function item_intlist(p_list in integers, p_index in integer) return integer deterministic;
	function item_numberlist(p_list in numbers, p_index in integer) return number deterministic;
	function item_strlist(p_list in varchars, p_index in integer) return varchar2 deterministic;
	function item_cloblist(p_list in clobs, p_index in integer) return clob deterministic;
	function item_datetimelist(p_list in dates, p_index in integer) return date deterministic;

	/******************************************************************************\
	The following functions implement the vSQL slice operator for various argument
	types.
	\******************************************************************************/
	function slice_str(p_str in varchar2, p_index1 in integer, p_index2 in integer) return varchar2 deterministic;
	function slice_clob(p_str in clob, p_index1 in integer, p_index2 in integer) return clob deterministic;
	function slice_intlist(p_list in integers, p_index1 in integer, p_index2 in integer) return integers deterministic;
	function slice_numberlist(p_list in numbers, p_index1 in integer, p_index2 in integer) return numbers deterministic;
	function slice_strlist(p_list in varchars, p_index1 in integer, p_index2 in integer) return varchars deterministic;
	function slice_cloblist(p_list in clobs, p_index1 in integer, p_index2 in integer) return clobs deterministic;
	function slice_datetimelist(p_list in dates, p_index1 in integer, p_index2 in integer) return dates deterministic;
	function slice_nulllist(p_list in integer, p_index1 in integer, p_index2 in integer) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL bitwise and operator (`x & y`).
	\******************************************************************************/
	function bitand_intset(p_set1 integers, p_set2 integers) return integers deterministic;
	function bitand_numberset(p_set1 numbers, p_set2 numbers) return numbers deterministic;
	function bitand_strset(p_set1 varchars, p_set2 varchars) return varchars deterministic;
	function bitand_datetimeset(p_set1 dates, p_set2 dates) return dates deterministic;

	/******************************************************************************\
	The following function implements the vSQL bitwise or operator (`x | y`).
	\******************************************************************************/
	function bitor_int(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function bitor_intset(p_set1 integers, p_set2 integers) return integers deterministic;
	function bitor_numberset(p_set1 numbers, p_set2 numbers) return numbers deterministic;
	function bitor_strset(p_set1 varchars, p_set2 varchars) return varchars deterministic;
	function bitor_datetimeset(p_set1 dates, p_set2 dates) return dates deterministic;

	/******************************************************************************\
	The following function implements the vSQL bitwise exclusive or operator
	(`x ^ y`).
	\******************************************************************************/
	function bitxor_int(p_value1 in integer, p_value2 in integer) return integer deterministic;
	function bitxor_intset(p_set1 integers, p_set2 integers) return integers deterministic;
	function bitxor_numberset(p_set1 numbers, p_set2 numbers) return numbers deterministic;
	function bitxor_strset(p_set1 varchars, p_set2 varchars) return varchars deterministic;
	function bitxor_datetimeset(p_set1 dates, p_set2 dates) return dates deterministic;

	/******************************************************************************\
	The following functions implement the vSQL function `bool` for various
	argument types.
	\******************************************************************************/
	function bool_clob(p_clob in clob) return integer deterministic;
	function bool_intlist(p_list in integers) return integer deterministic;
	function bool_numberlist(p_list in numbers) return integer deterministic;
	function bool_strlist(p_list in varchars) return integer deterministic;
	function bool_cloblist(p_list in clobs) return integer deterministic;
	function bool_datetimelist(p_list in dates) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL function `int` for various argument
	types.
	\******************************************************************************/
	function int_number(p_number in number) return integer deterministic;
	function int_str(p_str in varchar2) return integer deterministic;
	function int_clob(p_clob in clob) return integer deterministic;

	/******************************************************************************\
	The following functions implement the vSQL function `float` for various
	argument types.
	\******************************************************************************/
	function float_str(p_str in varchar2) return number deterministic;
	function float_clob(p_clob in clob) return number deterministic;

	/******************************************************************************\
	The following functions implement the vSQL function `str` for various argument
	types.
	\******************************************************************************/
	function str_number(p_value number) return varchar2 deterministic;
	function str_datedelta(p_delta integer) return varchar2 deterministic;
	function str_datetimedelta(p_delta number) return varchar2 deterministic;
	function str_monthdelta(p_delta integer) return varchar2 deterministic;
	function str_color(p_color integer) return varchar2 deterministic;

	/******************************************************************************\
	The following functions implement the vSQL function `repr` for various
	argument types.
	\******************************************************************************/
	function repr_int(p_value integer) return varchar2 deterministic;
	function repr_number(p_value number) return varchar2 deterministic;
	function repr_str(p_value varchar2) return varchar2 deterministic;
	function repr_clob(p_value clob) return clob deterministic;
	function repr_date(p_value in date) return varchar2 deterministic;
	function repr_datetime(p_value date) return varchar2 deterministic;
	function repr_datedelta(p_value integer) return varchar2 deterministic;
	function repr_datetimedelta(p_value number) return varchar2 deterministic;
	function repr_monthdelta(p_value integer) return varchar2 deterministic;
	function repr_color(p_color integer) return varchar2 deterministic;
	function repr_geo(p_geo varchar2) return varchar2 deterministic;
	function repr_nulllist(p_list integer) return varchar2 deterministic;
	function repr_intlist(p_list integers) return varchar2 deterministic;
	function repr_numberlist(p_list numbers) return varchar2 deterministic;
	function repr_strlist(p_list varchars) return varchar2 deterministic;
	function repr_cloblist(p_list clobs) return clob deterministic;
	function repr_datelist(p_list dates) return varchar2 deterministic;
	function repr_datetimelist(p_list dates) return varchar2 deterministic;
	function repr_nullset(p_list integer) return varchar2 deterministic;
	function repr_intset(p_list integers) return varchar2 deterministic;
	function repr_numberset(p_list numbers) return varchar2 deterministic;
	function repr_strset(p_list varchars) return varchar2 deterministic;
	function repr_dateset(p_list dates) return varchar2 deterministic;
	function repr_datetimeset(p_list dates) return varchar2 deterministic;

	/******************************************************************************\
	The following functions implement various other vSQL functions.
	\******************************************************************************/
	function rgb(p_r in number, p_g in number, p_b in number, p_a in number := 1.0) return integer deterministic;
	function geo_number_number_str(p_lat number, p_long number, p_info varchar2) return varchar2 deterministic;

	/******************************************************************************\
	The following functions implement vSQL attribute access for various argument
	types and attribute names.
	\******************************************************************************/
	function attr_color_r(p_color integer) return integer deterministic;
	function attr_color_g(p_color integer) return integer deterministic;
	function attr_color_b(p_color integer) return integer deterministic;
	function attr_color_a(p_color integer) return integer deterministic;
	function attr_geo_lat(p_geo varchar2) return number deterministic;
	function attr_geo_long(p_geo varchar2) return number deterministic;
	function attr_geo_info(p_geo varchar2) return varchar2 deterministic;
	function attr_date_weekday(p_date date) return integer deterministic;

	/******************************************************************************\
	The following functions implement various vSQL functions.
	\******************************************************************************/
	function date_int(p_year in integer, p_month in integer, p_day in integer) return date deterministic;
	function datetime_int(p_year in integer, p_month in integer, p_day in integer, p_hour in integer := 0, p_minute in integer := 0, p_second in integer := 0) return date deterministic;
	function len_intlist(p_list integers) return integer deterministic;
	function len_numberlist(p_list numbers) return integer deterministic;
	function len_strlist(p_list varchars) return integer deterministic;
	function len_cloblist(p_list clobs) return integer deterministic;
	function len_datetimelist(p_list dates) return integer deterministic;
	function list_str(p_str varchar2) return varchars deterministic;
	function list_clob(p_clob clob) return varchars deterministic;
	function set_str(p_str varchar2) return varchars deterministic;
	function set_intlist(p_list integers) return integers deterministic;
	function set_numberlist(p_list numbers) return numbers deterministic;
	function set_strlist(p_list varchars) return varchars deterministic;
	function set_datetimelist(p_list dates) return dates deterministic;
	function dist_geo_geo(p_geo1 varchar2, p_geo2 varchar2) return number deterministic;

	/******************************************************************************\
	The following functions implement various vSQL methods.
	\******************************************************************************/
	function startswith_clob_str(p_haystack clob, p_prefix varchar2) return integer deterministic;
	function startswith_clob_strlist(p_haystack clob, p_prefixes varchars) return integer deterministic;
	function startswith_str_str(p_haystack varchar2, p_prefix varchar2) return integer deterministic;
	function startswith_str_strlist(p_haystack varchar2, p_prefixes varchars) return integer deterministic;
	function endswith_clob_str(p_haystack clob, p_suffix varchar2) return integer deterministic;
	function endswith_clob_strlist(p_haystack clob, p_suffixes varchars) return integer deterministic;
	function endswith_str_str(p_haystack varchar2, p_suffix varchar2) return integer deterministic;
	function endswith_str_strlist(p_haystack varchar2, p_suffixes varchars) return integer deterministic;
	function strip_clob(p_clob in clob, p_strip in varchar2, p_lstrip in integer, p_rstrip in integer) return clob deterministic;
	function strip_str(p_str in varchar2, p_strip in varchar2, p_lstrip in integer, p_rstrip in integer) return varchar2 deterministic;
	function find_str_str(p_haystack in varchar2, p_needle in varchar2, p_start in integer, p_stop in integer) return integer deterministic;
	function find_str_clob(p_haystack in varchar2, p_needle in clob, p_start in integer, p_stop in integer) return integer deterministic;
	function find_clob_str(p_haystack in clob, p_needle in varchar2, p_start in integer, p_stop in integer) return integer deterministic;
	function find_clob_clob(p_haystack in clob, p_needle in clob, p_start in integer, p_stop in integer) return integer deterministic;
	function split_str_str(p_string in varchar2, p_separator in varchar2, p_maxsplit in integer := null) return varchars deterministic;
	function split_clob_str(p_string in clob, p_separator in varchar2, p_maxsplit in integer := null) return clobs deterministic;
	function join_str_str(p_separator in varchar2, p_list in varchar2) return varchar2 deterministic;
	function join_str_strlist(p_separator in varchar2, p_list in varchars) return varchar2 deterministic;
	function join_str_clob(p_separator in varchar2, p_list in clob) return clob deterministic;
	function join_str_cloblist(p_separator in varchar2, p_list in clobs) return clob deterministic;
	function lum(p_color integer) return number deterministic;

	/******************************************************************************\
	The following are some helper functions.
	\******************************************************************************/
	function intlist_fromlen(p_len integer) return integers deterministic;
	function numberlist_fromlen(p_len integer) return numbers deterministic;
	function strlist_fromlen(p_len integer) return varchars deterministic;
	function cloblist_fromlen(p_len integer) return clobs deterministic;
	function datetimelist_fromlen(p_len integer) return dates deterministic;
end;

/

create or replace package body VSQLIMPL_PKG
as
	function item_index(
		p_pos integer,
		p_size integer
	)
	return integer
	as
		v_pos integer;
	begin
		v_pos := p_pos;
		if v_pos is null then
			return null;
		end if;
		if v_pos < 0 then
			v_pos := v_pos + p_size;
		end if;
		if v_pos < 0 then
			return null;
		elsif v_pos >= p_size then
			return null;
		else
			return v_pos;
		end if;
	end;

	function slice_start(
		p_pos integer,
		p_size integer
	)
	return integer
	as
		v_pos integer;
	begin
		v_pos := p_pos;
		if v_pos is null then
			return 0;
		end if;
		if v_pos < 0 then
			v_pos := v_pos + p_size;
		end if;
		if v_pos < 0 then
			return 0;
		elsif v_pos >= p_size then
			return p_size;
		else
			return v_pos;
		end if;
	end;

	function slice_stop(
		p_pos integer,
		p_size integer
	)
	return integer
	as
		v_pos integer;
	begin
		v_pos := p_pos;
		if v_pos is null then
			return p_size;
		end if;
		if v_pos < 0 then
			v_pos := v_pos + p_size;
		end if;
		if v_pos < 0 then
			return 0;
		elsif v_pos >= p_size then
			return p_size;
		else
			return v_pos;
		end if;
	end;

	procedure geo_parse(
		p_geo in varchar2,
		p_lat out number,
		p_long out number,
		p_info out varchar2
	)
	deterministic
	as
		v_pos1 integer;
		v_pos2 integer;
	begin
		if p_geo is null then
			p_lat := null;
			p_long := null;
			p_info := null;
		else
			v_pos1 := instr(p_geo, ',', 1, 1);
			v_pos2 := instr(p_geo, ',', 1, 2);
			if v_pos1 = 0 then -- With only one part, we assume the complete string to be to info
				p_lat := null;
				p_long := null;
				p_info := p_geo;
			else
				begin
					p_lat := to_number(trim(substr(p_geo, 1, v_pos1-1)), '999.9999999999999999', 'NLS_NUMERIC_CHARACTERS = ''.,''');
				exception when others then
					p_lat := null;
				end;

				if v_pos2 = 0 then
					v_pos2 := length(p_geo)+1;
				end if;

				begin
					p_long := to_number(trim(substr(p_geo, v_pos1+1, v_pos2-v_pos1-1)), '999.9999999999999999', 'NLS_NUMERIC_CHARACTERS = ''.,''');
				exception when others then
					p_long := null;
				end;

				p_info := trim(substr(p_geo, v_pos2+1));
			end if;
		end if;
	end;

	function eq_int_int(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_int_number(
		p_value1 in integer,
		p_value2 in number
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_number_int(
		p_value1 in number,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_number_number(
		p_value1 in number,
		p_value2 in number
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_datetime_datetime(
		p_value1 in date,
		p_value2 in date
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_datetimedelta_datetimedelta(
		p_value1 in number,
		p_value2 in number
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif trunc(p_value1) = trunc(p_value2) and trunc(mod(p_value1, 1) * 86400 + 0.5) = trunc(mod(p_value2, 1) * 86400 + 0.5) then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_str_str(
		p_value1 in varchar2,
		p_value2 in varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_str_clob(
		p_value1 in varchar2,
		p_value2 in clob
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null or length(p_value2) = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null or length(p_value2) = 0 then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_clob_str(
		p_value1 in clob,
		p_value2 in varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null or length(p_value1) = 0 then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_clob_clob(
		p_value1 in clob,
		p_value2 in clob
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null or length(p_value1) = 0 then
			if p_value2 is null or length(p_value2) = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null or length(p_value2) = 0 then
				return 0;
			elsif p_value1 = p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_intlist_intlist(
		p_value1 in integers,
		p_value2 in integers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_int_int(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_intlist_numberlist(
		p_value1 in integers,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_int_number(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_numberlist_intlist(
		p_value1 in numbers,
		p_value2 in integers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_number_int(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_numberlist_numberlist(
		p_value1 in numbers,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_number_number(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_strlist_strlist(
		p_value1 in varchars,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_str_str(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_strlist_cloblist(
		p_value1 in varchars,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_str_clob(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_cloblist_strlist(
		p_value1 in clobs,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_clob_str(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_cloblist_cloblist(
		p_value1 in clobs,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_clob_clob(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_datetimelist_datetimelist(
		p_value1 in dates,
		p_value2 in dates
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if eq_datetime_datetime(p_value1(i), p_value2(i)) = 0 then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_nulllist_nulllist(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if nvl(p_value1, -1) = nvl(p_value2, -1) then
			return 1;
		else
			return 0;
		end if;
	end;

	function eq_nulllist_intlist(
		p_value1 in integer,
		p_value2 in integers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1 != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value2.count loop
						if p_value2(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_nulllist_numberlist(
		p_value1 in integer,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1 != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value2.count loop
						if p_value2(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_nulllist_strlist(
		p_value1 in integer,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1 != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value2.count loop
						if p_value2(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_nulllist_cloblist(
		p_value1 in integer,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1 != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value2.count loop
						if p_value2(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_nulllist_datetimelist(
		p_value1 in integer,
		p_value2 in dates
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1 != p_value2.count then
					return 0;
				else
					for i in 1 .. p_value2.count loop
						if p_value2(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_intlist_nulllist(
		p_value1 in integers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2 then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if p_value1(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_numberlist_nulllist(
		p_value1 in numbers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2 then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if p_value1(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_strlist_nulllist(
		p_value1 in varchars,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2 then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if p_value1(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_cloblist_nulllist(
		p_value1 in clobs,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2 then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if p_value1(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_datetimelist_nulllist(
		p_value1 in dates,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2 is null then
				return 0;
			else
				if p_value1.count != p_value2 then
					return 0;
				else
					for i in 1 .. p_value1.count loop
						if p_value1(i) is not null then
							return 0;
						end if;
					end loop;
					return 1;
				end if;
			end if;
		end if;
	end;

	function eq_intset_intset(
		p_value1 in integers,
		p_value2 in integers
	)
	return integer
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_set2 setdict;
		v_set1_has_null integer;
		v_set2_has_null integer;
		v_key varchar2(40);
	begin
		if p_value1 is null or p_value1.count = 0 then
			if p_value2 is null or p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		end if;

		v_set1_has_null := 0;
		for i in 1 .. p_value1.count loop
			if p_value1(i) is null then
				v_set1_has_null := 1;
			else
				v_set1(p_value1(i)) := 1;
			end if;
		end loop;

		v_set2_has_null := 0;
		for i in 1 .. p_value2.count loop
			if p_value2(i) is null then
				v_set2_has_null := 1;
			else
				v_set2(p_value2(i)) := 1;
			end if;
		end loop;

		if v_set1.count != v_set2.count then
			return 0;
		elsif v_set1_has_null != v_set2_has_null then
			return 0;
		else
			v_key := v_set1.first;
			while v_key is not null loop
				if not v_set2.exists(v_key) then
					return 0;
				end if;
				v_key := v_set1.next(v_key);
			end loop;
			return 1;
		end if;
	end;

	function eq_numberset_numberset(
		p_value1 in numbers,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_set2 setdict;
		v_set1_has_null integer;
		v_set2_has_null integer;
		v_key varchar2(100);
	begin
		if p_value1 is null or p_value1.count = 0 then
			if p_value2 is null or p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		end if;

		v_set1_has_null := 0;
		for i in 1 .. p_value1.count loop
			if p_value1(i) is null then
				v_set1_has_null := 1;
			else
				v_set1(p_value1(i)) := 1;
			end if;
		end loop;

		v_set2_has_null := 0;
		for i in 1 .. p_value2.count loop
			if p_value2(i) is null then
				v_set2_has_null := 1;
			else
				v_set2(p_value2(i)) := 1;
			end if;
		end loop;

		if v_set1.count != v_set2.count then
			return 0;
		elsif v_set1_has_null != v_set2_has_null then
			return 0;
		else
			v_key := v_set1.first;
			while v_key is not null loop
				if not v_set2.exists(v_key) then
					return 0;
				end if;
				v_key := v_set1.next(v_key);
			end loop;
			return 1;
		end if;
	end;

	function eq_strset_strset(
		p_value1 in varchars,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set1 setdict;
		v_set2 setdict;
		v_set1_has_null integer;
		v_set2_has_null integer;
		v_key varchar2(4000);
	begin
		if p_value1 is null or p_value1.count = 0 then
			if p_value2 is null or p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		end if;

		v_set1_has_null := 0;
		for i in 1 .. p_value1.count loop
			if p_value1(i) is null then
				v_set1_has_null := 1;
			else
				v_set1(p_value1(i)) := 1;
			end if;
		end loop;

		v_set2_has_null := 0;
		for i in 1 .. p_value2.count loop
			if p_value2(i) is null then
				v_set2_has_null := 1;
			else
				v_set2(p_value2(i)) := 1;
			end if;
		end loop;

		if v_set1.count != v_set2.count then
			return 0;
		elsif v_set1_has_null != v_set2_has_null then
			return 0;
		else
			v_key := v_set1.first;
			while v_key is not null loop
				if not v_set2.exists(v_key) then
					return 0;
				end if;
				v_key := v_set1.next(v_key);
			end loop;
			return 1;
		end if;
	end;

	function eq_datetimeset_datetimeset(
		p_value1 in dates,
		p_value2 in dates
	)
	return integer
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_set2 setdict;
		v_set1_has_null integer;
		v_set2_has_null integer;
		v_key varchar2(100);
	begin
		if p_value1 is null or p_value1.count = 0 then
			if p_value2 is null or p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		end if;

		v_set1_has_null := 0;
		for i in 1 .. p_value1.count loop
			if p_value1(i) is null then
				v_set1_has_null := 1;
			else
				v_set1(p_value1(i)) := 1;
			end if;
		end loop;

		v_set2_has_null := 0;
		for i in 1 .. p_value2.count loop
			if p_value2(i) is null then
				v_set2_has_null := 1;
			else
				v_set2(p_value2(i)) := 1;
			end if;
		end loop;

		if v_set1.count != v_set2.count then
			return 0;
		elsif v_set1_has_null != v_set2_has_null then
			return 0;
		else
			v_key := v_set1.first;
			while v_key is not null loop
				if not v_set2.exists(v_key) then
					return 0;
				end if;
				v_key := v_set1.next(v_key);
			end loop;
			return 1;
		end if;
	end;

	function eq_nullset_nullset(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if nvl(least(1, p_value1), -1) = nvl(least(1, p_value2), -1) then
			return 1;
		else
			return 0;
		end if;
	end;

	function eq_nullset_intset(
		p_value1 in integer,
		p_value2 in integers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value1 = 0 then
			if p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2.count = 1 and p_value2(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_nullset_numberset(
		p_value1 in integer,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value1 = 0 then
			if p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2.count = 1 and p_value2(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_nullset_strset(
		p_value1 in integer,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value1 = 0 then
			if p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2.count = 1 and p_value2(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_nullset_datetimeset(
		p_value1 in integer,
		p_value2 in dates
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value1 = 0 then
			if p_value2.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value2.count = 1 and p_value2(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_intset_nullset(
		p_value1 in integers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value2 is null then
			if p_value1 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value2 = 0 then
			if p_value1.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value1.count = 1 and p_value1(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_numberset_nullset(
		p_value1 in numbers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value2 is null then
			if p_value1 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value2 = 0 then
			if p_value1.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value1.count = 1 and p_value1(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_strset_nullset(
		p_value1 in varchars,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value2 is null then
			if p_value1 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value2 = 0 then
			if p_value1.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value1.count = 1 and p_value1(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function eq_datetimeset_nullset(
		p_value1 in dates,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value2 is null then
			if p_value1 is null then
				return 1;
			else
				return 0;
			end if;
		elsif p_value2 = 0 then
			if p_value1.count = 0 then
				return 1;
			else
				return 0;
			end if;
		else
			if p_value1.count = 1 and p_value1(1) is null then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_int_int(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_int_number(
		p_value1 in integer,
		p_value2 in number
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_number_int(
		p_value1 in number,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_number_number(
		p_value1 in number,
		p_value2 in number
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_datetime_datetime(
		p_value1 in date,
		p_value2 in date
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_str_str(
		p_value1 in varchar2,
		p_value2 in varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			elsif p_value1 < p_value2 then
				return -1;
			elsif p_value1 > p_value2 then
				return 1;
			else
				return 0;
			end if;
		end if;
	end;

	function cmp_str_clob(
		p_value1 in varchar2,
		p_value2 in clob
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null or length(p_value2) = 0 then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null or length(p_value2) = 0 then
				return 1;
			else
				return dbms_lob.compare(p_value1, p_value2);
			end if;
		end if;
	end;

	function cmp_clob_str(
		p_value1 in clob,
		p_value2 in varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null or length(p_value1) = 0 then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				return dbms_lob.compare(p_value1, p_value2);
			end if;
		end if;
	end;

	function cmp_clob_clob(
		p_value1 in clob,
		p_value2 in clob
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null or length(p_value1) = 0 then
			if p_value2 is null or length(p_value2) = 0 then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null or length(p_value2) = 0 then
				return 1;
			else
				return dbms_lob.compare(p_value1, p_value2);
			end if;
		end if;
	end;

	function cmp_intlist_intlist(
		p_value1 in integers,
		p_value2 in integers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_int_int(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_intlist_numberlist(
		p_value1 in integers,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_int_int(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_numberlist_intlist(
		p_value1 in numbers,
		p_value2 in integers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_int_int(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_numberlist_numberlist(
		p_value1 in numbers,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_int_int(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_strlist_strlist(
		p_value1 in varchars,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_str_str(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_strlist_cloblist(
		p_value1 in varchars,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_str_clob(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_cloblist_strlist(
		p_value1 in clobs,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_clob_str(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_cloblist_cloblist(
		p_value1 in clobs,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_clob_clob(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_datetimelist_datetimelist(
		p_value1 in dates,
		p_value2 in dates
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2.count) loop
					v_subcmp := cmp_datetime_datetime(p_value1(i), p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2.count then
					return -1;
				elsif p_value1.count > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_nulllist(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				if p_value1 < p_value2 then
					return -1;
				elsif p_value1 > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_intlist(
		p_value1 in integer,
		p_value2 in integers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1, p_value2.count) loop
					v_subcmp := cmp_int_int(null, p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1 < p_value2.count then
					return -1;
				elsif p_value1 > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_numberlist(
		p_value1 in integer,
		p_value2 in numbers
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1, p_value2.count) loop
					v_subcmp := cmp_number_number(null, p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1 < p_value2.count then
					return -1;
				elsif p_value1 > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_strlist(
		p_value1 in integer,
		p_value2 in varchars
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1, p_value2.count) loop
					v_subcmp := cmp_str_str(null, p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1 < p_value2.count then
					return -1;
				elsif p_value1 > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_cloblist(
		p_value1 in integer,
		p_value2 in clobs
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1, p_value2.count) loop
					v_subcmp := cmp_clob_clob(null, p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1 < p_value2.count then
					return -1;
				elsif p_value1 > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_nulllist_datetimelist(
		p_value1 in integer,
		p_value2 in dates
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1, p_value2.count) loop
					v_subcmp := cmp_datetime_datetime(null, p_value2(i));
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1 < p_value2.count then
					return -1;
				elsif p_value1 > p_value2.count then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_intlist_nulllist(
		p_value1 in integers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2) loop
					v_subcmp := cmp_int_int(p_value1(i), null);
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2 then
					return -1;
				elsif p_value1.count > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_numberlist_nulllist(
		p_value1 in numbers,
		p_value2 in integer
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2) loop
					v_subcmp := cmp_number_number(p_value1(i), null);
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2 then
					return -1;
				elsif p_value1.count > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_strlist_nulllist(
		p_value1 in varchars,
		p_value2 in integer
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2) loop
					v_subcmp := cmp_str_str(p_value1(i), null);
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2 then
					return -1;
				elsif p_value1.count > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_cloblist_nulllist(
		p_value1 in clobs,
		p_value2 in integer
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2) loop
					v_subcmp := cmp_clob_clob(p_value1(i), null);
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2 then
					return -1;
				elsif p_value1.count > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function cmp_datetimelist_nulllist(
		p_value1 in dates,
		p_value2 in integer
	)
	return integer
	deterministic
	as
		v_subcmp integer;
	begin
		if p_value1 is null then
			if p_value2 is null then
				return 0;
			else
				return -1;
			end if;
		else
			if p_value2 is null then
				return 1;
			else
				for i in 1 .. least(p_value1.count, p_value2) loop
					v_subcmp := cmp_datetime_datetime(p_value1(i), null);
					if v_subcmp != 0 then
						return v_subcmp;
					end if;
				end loop;
				if p_value1.count < p_value2 then
					return -1;
				elsif p_value1.count > p_value2 then
					return 1;
				else
					return 0;
				end if;
			end if;
		end if;
	end;

	function add_intlist_intlist(
		p_list1 in integers,
		p_list2 in integers
	)
	return integers
	deterministic
	as
		v_result integers;
	begin
		v_result := integers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_intlist_numberlist(
		p_list1 in integers,
		p_list2 in numbers
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_numberlist_intlist(
		p_list1 in numbers,
		p_list2 in integers
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_numberlist_numberlist(
		p_list1 in numbers,
		p_list2 in numbers
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_strlist_strlist(
		p_list1 in varchars,
		p_list2 in varchars
	)
	return varchars
	deterministic
	as
		v_result varchars;
	begin
		v_result := varchars();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_strlist_cloblist(
		p_list1 in varchars,
		p_list2 in clobs
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_cloblist_strlist(
		p_list1 in clobs,
		p_list2 in varchars
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_cloblist_cloblist(
		p_list1 in clobs,
		p_list2 in clobs
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_datetimelist_datetimelist(
		p_list1 in dates,
		p_list2 in dates
	)
	return dates
	deterministic
	as
		v_result dates;
	begin
		v_result := dates();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_nulllist_intlist(
		p_list1 in integer,
		p_list2 in integers
	)
	return integers
	deterministic
	as
		v_result integers;
	begin
		v_result := integers();
		if p_list1 is not null then
			for i in 1..p_list1 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_nulllist_numberlist(
		p_list1 in integer,
		p_list2 in numbers
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		if p_list1 is not null then
			for i in 1..p_list1 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_nulllist_strlist(
		p_list1 in integer,
		p_list2 in varchars
	)
	return varchars
	deterministic
	as
		v_result varchars;
	begin
		v_result := varchars();
		if p_list1 is not null then
			for i in 1..p_list1 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_nulllist_cloblist(
		p_list1 in integer,
		p_list2 in clobs
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		if p_list1 is not null then
			for i in 1..p_list1 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_nulllist_datetimelist(
		p_list1 in integer,
		p_list2 in dates
	)
	return dates
	deterministic
	as
		v_result dates;
	begin
		v_result := dates();
		if p_list1 is not null then
			for i in 1..p_list1 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2.count loop
				v_result.extend;
				v_result(v_result.last) := p_list2(i);
			end loop;
		end if;
		return v_result;
	end;

	function add_intlist_nulllist(
		p_list1 in integers,
		p_list2 in integer
	)
	return integers
	deterministic
	as
		v_result integers;
	begin
		v_result := integers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		return v_result;
	end;

	function add_numberlist_nulllist(
		p_list1 in numbers,
		p_list2 in integer
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		return v_result;
	end;

	function add_strlist_nulllist(
		p_list1 in varchars,
		p_list2 in integer
	)
	return varchars
	deterministic
	as
		v_result varchars;
	begin
		v_result := varchars();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		return v_result;
	end;

	function add_cloblist_nulllist(
		p_list1 in clobs,
		p_list2 in integer
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		return v_result;
	end;

	function add_datetimelist_nulllist(
		p_list1 in dates,
		p_list2 in integer
	)
	return dates
	deterministic
	as
		v_result dates;
	begin
		v_result := dates();
		if p_list1 is not null then
			for i in 1..p_list1.count loop
				v_result.extend;
				v_result(v_result.last) := p_list1(i);
			end loop;
		end if;
		if p_list2 is not null then
			for i in 1..p_list2 loop
				v_result.extend;
				v_result(v_result.last) := null;
			end loop;
		end if;
		return v_result;
	end;

	function add_datetime_months(
		p_date in date,
		p_months in integer
	)
	return date
	deterministic
	as
		v_result date;
		v_day_org integer;
		v_day_res integer;
	begin
		if p_date is null or p_months is null then
			return null;
		end if;
		v_result := add_months(p_date, p_months);
		v_day_org := extract(day from p_date);
		v_day_res := extract(day from v_result);
		if v_day_res > v_day_org then
			v_result := v_result - (v_day_res-v_day_org);
		end if;
		return v_result;
	end;

	function add_months_datetime(
		p_months in integer,
		p_date in date
	)
	return date
	deterministic
	as
	begin
		return add_datetime_months(p_date, p_months);
	end;

	function mul_int_str(
		p_arg1 in integer,
		p_arg2 in varchar2
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		for i in 1 .. p_arg1 loop
			v_result := v_result || p_arg2;
		end loop;
		return v_result;
	end;

	function mul_int_clob(
		p_arg1 in integer,
		p_arg2 in clob
	)
	return clob
	deterministic
	as
		v_result clob := null;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		dbms_lob.createtemporary(v_result, true);
		for i in 1 .. p_arg1 loop
			dbms_lob.append(v_result, p_arg2);
		end loop;
		return v_result;
	end;

	function mul_int_intlist(
		p_arg1 in integer,
		p_arg2 in integers
	)
	return integers
	deterministic
	as
		v_result integers;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		v_result := integers();
		for i in 1 .. p_arg1 loop
			for j in 1 .. p_arg2.count loop
				v_result.extend;
				v_result(v_result.count) := p_arg2(j);
			end loop;
		end loop;
		return v_result;
	end;

	function mul_int_numberlist(
		p_arg1 in integer,
		p_arg2 in numbers
	)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		v_result := numbers();
		for i in 1 .. p_arg1 loop
			for j in 1 .. p_arg2.count loop
				v_result.extend;
				v_result(v_result.count) := p_arg2(j);
			end loop;
		end loop;
		return v_result;
	end;

	function mul_int_datetimelist(
		p_arg1 in integer,
		p_arg2 in dates
	)
	return dates
	deterministic
	as
		v_result dates;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		v_result := dates();
		for i in 1 .. p_arg1 loop
			for j in 1 .. p_arg2.count loop
				v_result.extend;
				v_result(v_result.count) := p_arg2(j);
			end loop;
		end loop;
		return v_result;
	end;

	function mul_int_strlist(
		p_arg1 in integer,
		p_arg2 in varchars
	)
	return varchars
	deterministic
	as
		v_result varchars;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		v_result := varchars();
		for i in 1 .. p_arg1 loop
			for j in 1 .. p_arg2.count loop
				v_result.extend;
				v_result(v_result.count) := p_arg2(j);
			end loop;
		end loop;
		return v_result;
	end;

	function mul_int_cloblist(
		p_arg1 in integer,
		p_arg2 in clobs
	)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		if p_arg1 is null or p_arg1 < 0 or p_arg2 is null then
			return null;
		end if;
		v_result := clobs();
		for i in 1 .. p_arg1 loop
			for j in 1 .. p_arg2.count loop
				v_result.extend;
				v_result(v_result.count) := p_arg2(j);
			end loop;
		end loop;
		return v_result;
	end;

	function mul_str_int(
		p_arg1 in varchar2,
		p_arg2 in integer
	)
	return varchar2
	deterministic
	as
	begin
		return mul_int_str(p_arg2, p_arg1);
	end;

	function mul_clob_int(
		p_arg1 in clob,
		p_arg2 in integer
	)
	return clob
	deterministic
	as
	begin
		return mul_int_clob(p_arg2, p_arg1);
	end;

	function mul_intlist_int(
		p_arg1 in integers,
		p_arg2 in integer
	)
	return integers
	deterministic
	as
	begin
		return mul_int_intlist(p_arg2, p_arg1);
	end;

	function mul_numberlist_int(
		p_arg1 in numbers,
		p_arg2 in integer
	)
	return numbers
	deterministic
	as
	begin
		return mul_int_numberlist(p_arg2, p_arg1);
	end;

	function mul_datetimelist_int(
		p_arg1 in dates,
		p_arg2 in integer
	)
	return dates
	deterministic
	as
	begin
		return mul_int_datetimelist(p_arg2, p_arg1);
	end;

	function mul_strlist_int(
		p_arg1 in varchars,
		p_arg2 in integer
	)
	return varchars
	deterministic
	as
	begin
		return mul_int_strlist(p_arg2, p_arg1);
	end;

	function mul_cloblist_int(
		p_arg1 in clobs,
		p_arg2 in integer
	)
	return clobs
	deterministic
	as
	begin
		return mul_int_cloblist(p_arg2, p_arg1);
	end;

	function floordiv_int_int(
		p_arg1 in integer,
		p_arg2 in integer
	)
	return integer
	deterministic
	as
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			return floor(p_arg1/p_arg2);
		end if;
	end;

	function floordiv_int_number(
		p_arg1 in integer,
		p_arg2 in number
	)
	return number
	deterministic
	as
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			return floor(p_arg1/p_arg2);
		end if;
	end;

	function floordiv_number_int(
		p_arg1 in number,
		p_arg2 in integer
	)
	return number
	deterministic
	as
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			return floor(p_arg1/p_arg2);
		end if;
	end;

	function floordiv_number_number(
		p_arg1 in number,
		p_arg2 in number
	)
	return number
	deterministic
	as
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			return floor(p_arg1/p_arg2);
		end if;
	end;

	function mod_int_int(
		p_arg1 in integer,
		p_arg2 in integer
	)
	return integer
	deterministic
	as
		v_result integer;
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			v_result := mod(p_arg1, p_arg2);
			if p_arg2 > 0 then
				if v_result < 0 then
					v_result := v_result + p_arg2;
				end if;
			else
				if v_result > 0 then
					v_result := v_result + p_arg2;
				end if;
			end if;
			return v_result;
		end if;
	end;

	function mod_int_number(
		p_arg1 in integer,
		p_arg2 in number
	)
	return number
	deterministic
	as
		v_result number;
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			v_result := mod(p_arg1, p_arg2);
			if p_arg2 > 0 then
				if v_result < 0 then
					v_result := v_result + p_arg2;
				end if;
			else
				if v_result > 0 then
					v_result := v_result + p_arg2;
				end if;
			end if;
			return v_result;
		end if;
	end;

	function mod_number_int(
		p_arg1 in number,
		p_arg2 in integer
	)
	return number
	deterministic
	as
		v_result number;
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			v_result := mod(p_arg1, p_arg2);
			if p_arg2 > 0 then
				if v_result < 0 then
					v_result := v_result + p_arg2;
				end if;
			else
				if v_result > 0 then
					v_result := v_result + p_arg2;
				end if;
			end if;
			return v_result;
		end if;
	end;

	function mod_number_number(
		p_arg1 in number,
		p_arg2 in number
	)
	return number
	deterministic
	as
		v_result number;
	begin
		if p_arg1 is null or p_arg2 is null or p_arg2 = 0 then
			return null;
		else
			v_result := mod(p_arg1, p_arg2);
			if p_arg2 > 0 then
				if v_result < 0 then
					v_result := v_result + p_arg2;
				end if;
			else
				if v_result > 0 then
					v_result := v_result + p_arg2;
				end if;
			end if;
			return v_result;
		end if;
	end;

	function mod_color_color(
		p_color1 integer,
		p_color2 integer
	)
	return integer
	deterministic
	as
		v_r1 number(12, 9) := attr_color_r(p_color1);
		v_g1 number(12, 9) := attr_color_g(p_color1);
		v_b1 number(12, 9) := attr_color_b(p_color1);
		v_a1 number(12, 9) := attr_color_a(p_color1);
		v_r2 number(12, 9) := attr_color_r(p_color2);
		v_g2 number(12, 9) := attr_color_g(p_color2);
		v_b2 number(12, 9) := attr_color_b(p_color2);
		v_a2 number(12, 9) := attr_color_a(p_color2);
		v_rf number(12, 9);
		v_gf number(12, 9);
		v_bf number(12, 9);
		v_af number(12, 9);
	begin
		-- Scale components of p_color1 to the range [0, 1]
		v_r1 := v_r1/255;
		v_g1 := v_g1/255;
		v_b1 := v_b1/255;
		v_a1 := v_a1/255;

		-- Convert to premultiplied alpha
		v_r1 := v_r1 * v_a1;
		v_g1 := v_g1 * v_a1;
		v_b1 := v_b1 * v_a1;

		-- Scale components of p_color2 to the range [0, 1]
		v_r2 := v_r2/255;
		v_g2 := v_g2/255;
		v_b2 := v_b2/255;
		v_a2 := v_a2/255;

		-- Convert to premultiplied alpha
		v_r2 := v_r2 * v_a2;
		v_g2 := v_g2 * v_a2;
		v_b2 := v_b2 * v_a2;

		-- Blend colors
		v_rf := v_r1 + v_r2 * (1.0 - v_a1);
		v_gf := v_g1 + v_g2 * (1.0 - v_a1);
		v_bf := v_b1 + v_b2 * (1.0 - v_a1);
		v_af := v_a1 + v_a2 * (1.0 - v_a1);

		-- Unmultiply alpha
		if v_af != 0 then
			v_rf := v_rf / v_af;
			v_gf := v_gf / v_af;
			v_bf := v_bf / v_af;
		end if;

		-- Scale final values back to the range [0, 255]
		return rgb(v_rf, v_gf, v_bf, v_af);
	end;

	function contains_str_str(
		p_needle in varchar2,
		p_haystack in varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return 1;
		elsif p_haystack is null then
			return 0;
		else
			if instr(p_haystack, p_needle) = 0 then
				return 0;
			else
				return 1;
			end if;
		end if;
	end;

	function contains_str_clob(
		p_needle in varchar2,
		p_haystack in clob
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return 1;
		elsif p_haystack is null or dbms_lob.getlength(p_haystack) = 0 then
			return 0;
		else
			if dbms_lob.instr(p_haystack, p_needle) = 0 then
				return 0;
			else
				return 1;
			end if;
		end if;
	end;

	function contains_null_nulllist(
		p_haystack in integer
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null and p_haystack > 0 then
			return 1;
		end if;
		return 0;
	end;

	function contains_null_intlist(
		p_haystack in integers
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null then
			for i in 1..p_haystack.count loop
				if p_haystack(i) is null then
					return 1;
				end if;
			end loop;
		end if;
		return 0;
	end;

	function contains_null_numberlist(
		p_haystack in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null then
			for i in 1..p_haystack.count loop
				if p_haystack(i) is null then
					return 1;
				end if;
			end loop;
		end if;
		return 0;
	end;

	function contains_null_datetimelist(
		p_haystack in dates
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null then
			for i in 1..p_haystack.count loop
				if p_haystack(i) is null then
					return 1;
				end if;
			end loop;
		end if;
		return 0;
	end;

	function contains_null_strlist(
		p_haystack in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null then
			for i in 1..p_haystack.count loop
				if p_haystack(i) is null then
					return 1;
				end if;
			end loop;
		end if;
		return 0;
	end;

	function contains_null_cloblist(
		p_haystack in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_haystack is not null then
			for i in 1..p_haystack.count loop
				if p_haystack(i) is null then
					return 1;
				end if;
			end loop;
		end if;
		return 0;
	end;

	function contains_int_intlist(
		p_needle in integer,
		p_haystack in integers
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_intlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_int_numberlist(
		p_needle in integer,
		p_haystack in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_numberlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_number_intlist(
		p_needle in number,
		p_haystack in integers
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_intlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_number_numberlist(
		p_needle in number,
		p_haystack in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_numberlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_str_strlist(
		p_needle in varchar2,
		p_haystack in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_strlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_str_cloblist(
		p_needle in varchar2,
		p_haystack in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_cloblist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if length(p_haystack(i)) = length(p_needle) and p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_clob_strlist(
		p_needle in clob,
		p_haystack in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null or length(p_needle) = 0 then
			return contains_null_strlist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if length(p_haystack(i)) = length(p_needle) and p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_clob_cloblist(
		p_needle in clob,
		p_haystack in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null or length(p_needle) = 0 then
			return contains_null_cloblist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function contains_datetime_datetimelist(
		p_needle in date,
		p_haystack in dates
	)
	return integer
	deterministic
	as
	begin
		if p_needle is null then
			return contains_null_datetimelist(p_haystack);
		else
			if p_haystack is not null then
				for i in 1..p_haystack.count loop
					if p_haystack(i) = p_needle then
						return 1;
					end if;
				end loop;
			end if;
			return 0;
		end if;
	end;

	function item_str(
		p_str in varchar2,
		p_index in integer
	)
	return varchar2
	deterministic
	as
		v_index integer;
	begin
		if p_str is null then
			return null;
		end if;
		v_index := item_index(p_index, length(p_str));
		if v_index is null then
			return null;
		else
			return substr(p_str, v_index+1, 1);
		end if;
	end;

	function item_clob(
		p_str in clob,
		p_index in integer
	)
	return varchar2
	deterministic
	as
		v_index integer;
	begin
		if p_str is null or length(p_str) = 0 then
			return null;
		end if;
		v_index := item_index(p_index, length(p_str));
		if v_index is null then
			return null;
		else
			return to_char(dbms_lob.substr(p_str, 1, v_index+1));
		end if;
	end;

	function item_intlist(
		p_list in integers,
		p_index in integer
	)
	return integer
	deterministic
	as
		v_index integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index := item_index(p_index, p_list.count);
		if v_index is null then
			return null;
		else
			return p_list(v_index+1);
		end if;
	end;

	function item_numberlist(
		p_list in numbers,
		p_index in integer
	)
	return number
	deterministic
	as
		v_index integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index := item_index(p_index, p_list.count);
		if v_index is null then
			return null;
		else
			return p_list(v_index+1);
		end if;
	end;

	function item_strlist(
		p_list in varchars,
		p_index in integer
	)
	return varchar2
	deterministic
	as
		v_index integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index := item_index(p_index, p_list.count);
		if v_index is null then
			return null;
		else
			return p_list(v_index+1);
		end if;
	end;

	function item_cloblist(
		p_list in clobs,
		p_index in integer
	)
	return clob
	deterministic
	as
		v_index integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index := item_index(p_index, p_list.count);
		if v_index is null then
			return null;
		else
			return p_list(v_index+1);
		end if;
	end;

	function item_datetimelist(
		p_list in dates,
		p_index in integer
	)
	return date
	deterministic
	as
		v_index integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index := item_index(p_index, p_list.count);
		if v_index is null then
			return null;
		else
			return p_list(v_index+1);
		end if;
	end;

	function slice_str(
		p_str in varchar2,
		p_index1 in integer,
		p_index2 in integer
	)
	return varchar2
	deterministic
	as
		v_index1 integer;
		v_index2 integer;
	begin
		if p_str is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, length(p_str));
		v_index2 := slice_stop(p_index2, length(p_str));
		if v_index1 >= v_index2 then
			return null;
		else
			return substr(p_str, v_index1+1, v_index2-v_index1);
		end if;
	end;

	function slice_clob(
		p_str in clob,
		p_index1 in integer,
		p_index2 in integer
	)
	return clob
	deterministic
	as
		v_result clob;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_str is null or length(p_str) = 0 then
			return null;
		end if;
		v_index1 := slice_start(p_index1, length(p_str));
		v_index2 := slice_stop(p_index2, length(p_str));
		if v_index1 >= v_index2 then
			return null;
		else
			dbms_lob.createtemporary(v_result, true);
			dbms_lob.copy(v_result, p_str, v_index2-v_index1, 1, v_index1+1);
			return v_result;
		end if;
	end;

	function slice_intlist(
		p_list in integers,
		p_index1 in integer,
		p_index2 in integer
	)
	return integers
	deterministic
	as
		v_result integers;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list.count);
		v_index2 := slice_stop(p_index2, p_list.count);

		v_result := integers();
		for i in v_index1+1 .. v_index2 loop
			v_result.extend;
			v_result(v_result.last()) := p_list(i);
		end loop;
		return v_result;
	end;

	function slice_numberlist(
		p_list in numbers,
		p_index1 in integer,
		p_index2 in integer
	)
	return numbers
	deterministic
	as
		v_result numbers;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list.count);
		v_index2 := slice_stop(p_index2, p_list.count);

		v_result := numbers();
		for i in v_index1+1 .. v_index2 loop
			v_result.extend;
			v_result(v_result.last()) := p_list(i);
		end loop;
		return v_result;
	end;

	function slice_strlist(
		p_list in varchars,
		p_index1 in integer,
		p_index2 in integer
	)
	return varchars
	deterministic
	as
		v_result varchars;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list.count);
		v_index2 := slice_stop(p_index2, p_list.count);

		v_result := varchars();
		for i in v_index1+1 .. v_index2 loop
			v_result.extend;
			v_result(v_result.last()) := p_list(i);
		end loop;
		return v_result;
	end;

	function slice_cloblist(
		p_list in clobs,
		p_index1 in integer,
		p_index2 in integer
	)
	return clobs
	deterministic
	as
		v_result clobs;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list.count);
		v_index2 := slice_stop(p_index2, p_list.count);

		v_result := clobs();
		for i in v_index1+1 .. v_index2 loop
			v_result.extend;
			v_result(v_result.last()) := p_list(i);
		end loop;
		return v_result;
	end;

	function slice_datetimelist(
		p_list in dates,
		p_index1 in integer,
		p_index2 in integer
	)
	return dates
	deterministic
	as
		v_result dates;
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list.count);
		v_index2 := slice_stop(p_index2, p_list.count);

		v_result := dates();
		for i in v_index1+1 .. v_index2 loop
			v_result.extend;
			v_result(v_result.last()) := p_list(i);
		end loop;
		return v_result;
	end;

	function slice_nulllist(
		p_list in integer,
		p_index1 in integer,
		p_index2 in integer
	)
	return integer
	deterministic
	as
		v_index1 integer;
		v_index2 integer;
	begin
		if p_list is null then
			return null;
		end if;
		v_index1 := slice_start(p_index1, p_list);
		v_index2 := slice_stop(p_index2, p_list);

		return v_index2 - v_index1;
	end;

	function bitand_intset(
		p_set1 integers,
		p_set2 integers
	)
	return integers
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_result integers := integers();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 or p_set2 is null or p_set2.count = 0 then
			return v_result;
		end if;
		for i in 1 .. p_set1.count loop
			if p_set1(i) is null then
				v_set1null := 1;
			else
				v_set1(p_set1(i)) := 1;
			end if;
		end loop;
		for i in 1 .. p_set2.count loop
			if p_set2(i) is null then
				v_set2null := 1;
			else
				if v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end if;
		end loop;
		if v_set1null = 1 and v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitand_numberset(
		p_set1 numbers,
		p_set2 numbers
	)
	return numbers
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_result numbers := numbers();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 or p_set2 is null or p_set2.count = 0 then
			return v_result;
		end if;
		for i in 1 .. p_set1.count loop
			if p_set1(i) is null then
				v_set1null := 1;
			else
				v_set1(p_set1(i)) := 1;
			end if;
		end loop;
		for i in 1 .. p_set2.count loop
			if p_set2(i) is null then
				v_set2null := 1;
			else
				if v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end if;
		end loop;
		if v_set1null = 1 and v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitand_strset(
		p_set1 varchars,
		p_set2 varchars
	)
	return varchars
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set1 setdict;
		v_result varchars := varchars();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 or p_set2 is null or p_set2.count = 0 then
			return v_result;
		end if;
		for i in 1 .. p_set1.count loop
			if p_set1(i) is null then
				v_set1null := 1;
			else
				v_set1(p_set1(i)) := 1;
			end if;
		end loop;
		for i in 1 .. p_set2.count loop
			if p_set2(i) is null then
				v_set2null := 1;
			else
				if v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end if;
		end loop;
		if v_set1null = 1 and v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitand_datetimeset(
		p_set1 dates,
		p_set2 dates
	)
	return dates
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_result dates := dates();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 or p_set2 is null or p_set2.count = 0 then
			return v_result;
		end if;
		for i in 1 .. p_set1.count loop
			if p_set1(i) is null then
				v_set1null := 1;
			else
				v_set1(p_set1(i)) := 1;
			end if;
		end loop;
		for i in 1 .. p_set2.count loop
			if p_set2(i) is null then
				v_set2null := 1;
			else
				if v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end if;
		end loop;
		if v_set1null = 1 and v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitor_int(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer deterministic
	as
	begin
		return p_value1 + p_value2 - bitand(p_value1, p_value2);
	end;

	function bitor_intset(
		p_set1 integers,
		p_set2 integers
	)
	return integers
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_result integers := integers();
		v_setnull integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_setnull := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_setnull := 1;
				else
					if not v_set1.exists(p_set2(i)) then
						v_result.extend();
						v_result(v_result.count) := p_set2(i);
					end if;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
		end if;
		if v_setnull = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitor_numberset(
		p_set1 numbers,
		p_set2 numbers
	)
	return numbers
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_result numbers := numbers();
		v_setnull integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_setnull := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_setnull := 1;
				else
					if not v_set1.exists(p_set2(i)) then
						v_result.extend();
						v_result(v_result.count) := p_set2(i);
					end if;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
		end if;
		if v_setnull = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitor_strset(
		p_set1 varchars,
		p_set2 varchars
	)
	return varchars
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set1 setdict;
		v_result varchars := varchars();
		v_setnull integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_setnull := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_setnull := 1;
				else
					if not v_set1.exists(p_set2(i)) then
						v_result.extend();
						v_result(v_result.count) := p_set2(i);
					end if;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
		end if;
		if v_setnull = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitor_datetimeset(
		p_set1 dates,
		p_set2 dates
	)
	return dates
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_result dates := dates();
		v_setnull integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_setnull := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_setnull := 1;
				else
					if not v_set1.exists(p_set2(i)) then
						v_result.extend();
						v_result(v_result.count) := p_set2(i);
					end if;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
		end if;
		if v_setnull = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitxor_int(
		p_value1 in integer,
		p_value2 in integer
	)
	return integer deterministic
	as
	begin
		return bitor_int(p_value1, p_value2) - bitand(p_value1, p_value2);
	end;

	function bitxor_intset(
		p_set1 integers,
		p_set2 integers
	)
	return integers
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_set2 setdict;
		v_result integers := integers();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_set1null := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_set2null := 1;
				else
					v_set2(p_set2(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null and not v_set2.exists(p_set1(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is not null and not v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end loop;
		end if;
		if v_set1null + v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitxor_numberset(
		p_set1 numbers,
		p_set2 numbers
	)
	return numbers
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set1 setdict;
		v_set2 setdict;
		v_result numbers := numbers();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_set1null := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_set2null := 1;
				else
					v_set2(p_set2(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null and not v_set2.exists(p_set1(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is not null and not v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end loop;
		end if;
		if v_set1null + v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitxor_strset(
		p_set1 varchars,
		p_set2 varchars
	)
	return varchars
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set1 setdict;
		v_set2 setdict;
		v_result varchars := varchars();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_set1null := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_set2null := 1;
				else
					v_set2(p_set2(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null and not v_set2.exists(p_set1(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is not null and not v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end loop;
		end if;
		if v_set1null + v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bitxor_datetimeset(
		p_set1 dates,
		p_set2 dates
	)
	return dates
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set1 setdict;
		v_set2 setdict;
		v_result dates := dates();
		v_set1null integer := 0;
		v_set2null integer := 0;
	begin
		if p_set1 is null or p_set1.count = 0 then
			return p_set2;
		elsif p_set2 is null or p_set2.count = 0 then
			return p_set1;
		else
			for i in 1 .. p_set1.count loop
				if p_set1(i) is null then
					v_set1null := 1;
				else
					v_set1(p_set1(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is null then
					v_set2null := 1;
				else
					v_set2(p_set2(i)) := 1;
				end if;
			end loop;
			for i in 1 .. p_set1.count loop
				if p_set1(i) is not null and not v_set2.exists(p_set1(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set1(i);
				end if;
			end loop;
			for i in 1 .. p_set2.count loop
				if p_set2(i) is not null and not v_set1.exists(p_set2(i)) then
					v_result.extend();
					v_result(v_result.count) := p_set2(i);
				end if;
			end loop;
		end if;
		if v_set1null + v_set2null = 1 then
			v_result.extend();
		end if;
		return v_result;
	end;

	function bool_clob(
		p_clob in clob
	)
	return integer
	deterministic
	as
	begin
		if p_clob is null or dbms_lob.getlength(p_clob) = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function bool_intlist(
		p_list in integers
	)
	return integer
	deterministic
	as
	begin
		if p_list is null or p_list.count = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function bool_numberlist(
		p_list in numbers
	)
	return integer
	deterministic
	as
	begin
		if p_list is null or p_list.count = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function bool_strlist(
		p_list in varchars
	)
	return integer
	deterministic
	as
	begin
		if p_list is null or p_list.count = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function bool_cloblist(
		p_list in clobs
	)
	return integer
	deterministic
	as
	begin
		if p_list is null or p_list.count = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function bool_datetimelist(
		p_list in dates
	)
	return integer
	deterministic
	as
	begin
		if p_list is null or p_list.count = 0 then
			return 0;
		else
			return 1;
		end if;
	end;

	function int_number(
		p_number in number
	)
	return integer
	deterministic
	as
	begin
		if p_number is null then
			return null;
		elsif p_number > 0 then
			return floor(p_number);
		else
			return -floor(-p_number);
		end if;
	end;

	function int_str(
		p_str in varchar2
	)
	return integer
	deterministic
	as
		v_int integer;
	begin
		if p_str is null then
			return 0;
		else
			begin
				v_int := p_str;
			exception when others then
				v_int := null;
			end;
		end if;
		return v_int;
	end;

	function int_clob(
		p_clob in clob
	)
	return integer
	deterministic
	as
		v_int integer;
	begin
		if p_clob is null or dbms_lob.getlength(p_clob) = 0 then
			return 0;
		else
			begin
				if dbms_lob.getlength(p_clob) > 30000 then
					v_int := null;
				else
					v_int := cast(p_clob as varchar2);
				end if;
			exception when others then
				v_int := null;
			end;
		end if;
		return v_int;
	end;

	function float_str(
		p_str in varchar2
	)
	return number
	deterministic
	as
		v_float float;
	begin
		if p_str is null then
			return 0;
		else
			begin
				v_float := to_number(p_str, '99999999999999999999999999999999999999990.999999999999999999999');
			exception when others then
				v_float := null;
			end;
		end if;
		return v_float;
	end;

	function float_clob(
		p_clob in clob
	)
	return number
	deterministic
	as
		v_float number;
	begin
		if p_clob is null or dbms_lob.getlength(p_clob) = 0 then
			return 0;
		else
			begin
				if dbms_lob.getlength(p_clob) > 30000 then
					v_float := null;
				else
					v_float := cast(p_clob as varchar2);
				end if;
			exception when others then
				v_float := null;
			end;
		end if;
		return v_float;
	end;

	function str_number(
		p_value number
	)
	return varchar2
	deterministic
	as
		v_result varchar2(100);
	begin
		v_result := to_char(p_value, '99999999999999999999999999999999999999990.999999999999999999999');
		v_result := strip_str(v_result, '0', 0, 1);
		if v_result like '%.' then
			v_result := v_result || '0';
		end if;
		return trim(v_result);
	end;

	function str_datedelta(
		p_delta integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_delta is null then
			return null;
		elsif p_delta = 1 then
			return '1 day';
		else
			return p_delta || ' days';
		end if;
	end;

	function str_datetimedelta(
		p_delta number
	)
	return varchar2
	deterministic
	as
		v_days integer;
		v_hours integer;
		v_minutes integer;
		v_seconds integer;
	begin
		if p_delta is null then
			return null;
		end if;
		v_days := floor(p_delta);
		v_seconds := floor((p_delta-v_days)*86400 + 0.5);
		v_minutes := floor(v_seconds/60);
		v_seconds := mod(v_seconds, 60);
		v_hours := floor(v_minutes/60);
		v_minutes := mod(v_minutes, 60);
		if v_days = 0 then
			return v_hours || ':' || lpad(v_minutes, 2, '0') || ':' || lpad(v_seconds, 2, '0');
		elsif v_days = 1 then
			return '1 day, ' || v_hours || ':' || lpad(v_minutes, 2, '0') || ':' || lpad(v_seconds, 2, '0');
		else
			return v_days || ' days, ' || v_hours || ':' || lpad(v_minutes, 2, '0') || ':' || lpad(v_seconds, 2, '0');
		end if;
	end;

	function str_monthdelta(
		p_delta integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_delta is null then
			return null;
		elsif p_delta = 1 then
			return '1 month';
		else
			return p_delta || ' months';
		end if;
	end;

	function str_color(
		p_color integer
	)
	return varchar2
	deterministic
	as
		v_rawrepr varchar(9);
		v_r integer;
		v_g integer;
		v_b integer;
		v_a integer;
	begin
		v_rawrepr := trim(to_char(p_color, '0000000x'));
		-- No alpha -> output in '#...' format
		if substr(v_rawrepr, 7, 2) = 'ff' then
			if substr(v_rawrepr, 1, 1) = substr(v_rawrepr, 2, 1) and substr(v_rawrepr, 3, 1) = substr(v_rawrepr, 4, 1) and substr(v_rawrepr, 5, 1) = substr(v_rawrepr, 6, 1) then
				return '#' || substr(v_rawrepr, 1, 1) || substr(v_rawrepr, 3, 1) || substr(v_rawrepr, 5, 1);
			else
				return '#' || substr(v_rawrepr, 1, 6);
			end if;
		-- We have a alpha -> output in 'rgba(...)' format
		else
			v_r := to_number(substr(v_rawrepr, 1, 2), 'xx');
			v_g := to_number(substr(v_rawrepr, 3, 2), 'xx');
			v_b := to_number(substr(v_rawrepr, 5, 2), 'xx');
			v_a := to_number(substr(v_rawrepr, 7, 2), 'xx');
			return 'rgba(' || v_r || ', ' || v_g || ', ' || v_b || ', ' || trim(to_char(v_a/255, '0.999')) || ')';
		end if;
	end;

	function repr_int(
		p_value integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return to_char(p_value);
		end if;
	end;

	function repr_number(
		p_value number
	)
	return varchar2
	deterministic
	as
		v_str varchar2(100);
	begin
		if p_value is null then
			return 'None';
		else
			-- This converts the number back to a string, but must be cleaned up for a nice repr
			v_str := to_char(p_value, '999999999999999999999999999999999999999990.099999999999');
			-- Get rid of surrounding whitespace (for non-negative numbers)
			v_str := trim(v_str);
			-- Get rid of unneccessary trailing zeros
			while v_str like '%0' and v_str not like '%.0' loop
				v_str := substr(v_str, 1, length(v_str) -1 );
			end loop;
			return v_str;
		end if;
	end;

	function repr_strpart(
		p_value varchar2
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		v_result := p_value;
		v_result := replace(v_result, '\', '\\');
		v_result := asciistr(v_result);

		-- make proper unicode escapes
		v_result := replace(v_result, '\', '\u');

		-- revert backslash escape
		v_result := replace(v_result, '\u005C', '\');

		-- escape control characters
		for i in 1 .. 7 loop
			v_result := replace(v_result, chr(i), '\u00' || replace(substr(to_char(ascii(chr(i)), 'xx'), 2, 2), ' ', '0'));
		end loop;
		v_result := replace(v_result, chr(8), '\b');
		v_result := replace(v_result, chr(9), '\t');
		v_result := replace(v_result, chr(10), '\n');
		v_result := replace(v_result, chr(11), '\u00' || replace(substr(to_char(ascii(11), 'xx'), 2, 2), ' ', '0'));
		v_result := replace(v_result, chr(12), '\f');
		v_result := replace(v_result, chr(13), '\r');
		for i in 128 .. 159 loop
			v_result := replace(v_result, chr(i), '\u00' || replace(substr(to_char(ascii(chr(i)), 'xx'), 2, 2), ' ', '0'));
		end loop;
		-- Restore umlauts
		v_result := replace(v_result, '\u00E4', 'ä');
		v_result := replace(v_result, '\u00F6', 'ö');
		v_result := replace(v_result, '\u00FC', 'ü');
		v_result := replace(v_result, '\u00C4', 'Ä');
		v_result := replace(v_result, '\u00D6', 'Ö');
		v_result := replace(v_result, '\u00DC', 'Ü');
		v_result := replace(v_result, '\u00DF', 'ß');
		-- escape quote characters
		v_result := replace(v_result, '''', '\''');
		return v_result;
	end;

	function repr_str(
		p_value varchar2
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return '''' || repr_strpart(p_value) || '''';
		end if;
	end;

	function repr_clob(
		p_value clob
	)
	return clob
	deterministic
	as
		v_result clob;
		v_part varchar2(32000);
	begin
		if p_value is null then
			return 'None';
		else
			dbms_lob.createtemporary(v_result, true);
			dbms_lob.writeappend(v_result, 1, '''');
			for i in 0 .. trunc((dbms_lob.getlength(p_value) - 1)/10000) loop
				v_part := repr_strpart(dbms_lob.substr(p_value, 10000, i * 10000 + 1));
				dbms_lob.writeappend(v_result, length(v_part), v_part);
			end loop;
			dbms_lob.writeappend(v_result, 1, '''');
			return v_result;
		end if;
	end;

	function repr_date(
		p_value date
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return to_char(p_value, '"@("YYYY-MM-DD")"');
		end if;
	end;

	function repr_datetime(
		p_value date
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return to_char(p_value, '"@("YYYY-MM-DD"T"HH24:MI:SS")"');
		end if;
	end;

	function repr_datedelta(
		p_value integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return 'timedelta(' || p_value || ')';
		end if;
	end;

	function repr_datetimedelta(
		p_value number
	)
	return varchar2
	deterministic
	as
		v_days integer;
		v_seconds integer;
	begin
		if p_value is null then
			return 'None';
		else
			v_days := floor(p_value);
			v_seconds := floor((p_value-v_days)*86400 + 0.5);
			if v_seconds = 0 then
				return 'timedelta(' || v_days || ')';
			else
				return 'timedelta(' || v_days || ', ' || v_seconds || ')';
			end if;
		end if;
	end;

	function repr_monthdelta(
		p_value integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_value is null then
			return 'None';
		else
			return 'monthdelta(' || p_value || ')';
		end if;
	end;

	function repr_color(
		p_color integer
	)
	return varchar2
	deterministic
	as
		v_rawrepr varchar(9);
	begin
		v_rawrepr := trim(to_char(p_color, '0000000x'));
		if substr(v_rawrepr, 1, 1) = substr(v_rawrepr, 2, 1) and substr(v_rawrepr, 3, 1) = substr(v_rawrepr, 4, 1) and substr(v_rawrepr, 5, 1) = substr(v_rawrepr, 6, 1) and substr(v_rawrepr, 7, 1) = substr(v_rawrepr, 8, 1) then
			v_rawrepr := substr(v_rawrepr, 1, 1) || substr(v_rawrepr, 3, 1) || substr(v_rawrepr, 5, 1) || substr(v_rawrepr, 7, 1);
			if substr(v_rawrepr, 4, 1) = 'f' then
				v_rawrepr := substr(v_rawrepr, 1, 3);
			end if;
		else
			if substr(v_rawrepr, 7, 2) = 'ff' then
				v_rawrepr := substr(v_rawrepr, 1, 6);
			end if;
		end if;
		return '#' || v_rawrepr;
	end;

	function repr_geo(
		p_geo varchar2
	)
	return varchar2
	deterministic
	as
		v_lat number(15, 12);
		v_long number(15, 12);
		v_info varchar2(4000);
	begin
		geo_parse(p_geo, v_lat, v_long, v_info);
		return '<geo lat=' || repr_number(v_lat) || ' long=' || repr_number(v_long) || ' info=' || repr_str(v_info) || '>';
	end;

	function repr_nulllist(
		p_list integer
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || 'None';
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_intlist(
		p_list integers
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_int(p_list(i));
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_numberlist(
		p_list numbers
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_number(p_list(i));
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_strlist(
		p_list varchars
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_str(p_list(i));
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_cloblist(
		p_list clobs
	)
	return clob
	deterministic
	as
		v_result clob;
	begin
		if p_list is null then
			return 'None';
		else
			dbms_lob.createtemporary(v_result, true);
			dbms_lob.writeappend(v_result, 1, '[');
			for i in 1..p_list.count loop
				if i != 1 then
					dbms_lob.writeappend(v_result, 2, ', ');
				end if;
				dbms_lob.append(v_result, repr_clob(p_list(i)));
			end loop;
			dbms_lob.writeappend(v_result, 1, ']');
			return v_result;
		end if;
	end;

	function repr_datelist(
		p_list dates
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_date(p_list(i));
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_datetimelist(
		p_list dates
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '[';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_datetime(p_list(i));
			end loop;
			v_result := v_result || ']';
			return v_result;
		end if;
	end;

	function repr_nullset(
		p_list integer
	)
	return varchar2
	deterministic
	as
	begin
		if p_list is null then
			return 'None';
		elsif p_list = 0 then
			return '{}';
		else
			return '{None}';
		end if;
	end;

	function repr_intset(
		p_list integers
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '{';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_int(p_list(i));
			end loop;
			v_result := v_result || '}';
			return v_result;
		end if;
	end;

	function repr_numberset(
		p_list numbers
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '{';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_number(p_list(i));
			end loop;
			v_result := v_result || '}';
			return v_result;
		end if;
	end;

	function repr_strset(
		p_list varchars
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '{';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_str(p_list(i));
			end loop;
			v_result := v_result || '}';
			return v_result;
		end if;
	end;

	function repr_dateset(
		p_list dates
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '{';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_date(p_list(i));
			end loop;
			v_result := v_result || '}';
			return v_result;
		end if;
	end;

	function repr_datetimeset(
		p_list dates
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return 'None';
		else
			v_result := v_result || '{';
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || ', ';
				end if;
				v_result := v_result || repr_datetime(p_list(i));
			end loop;
			v_result := v_result || '}';
			return v_result;
		end if;
	end;

	function rgb(
		p_r in number,
		p_g in number,
		p_b in number,
		p_a in number := 1.0
	)
	return integer
	deterministic
	as
		v_r integer;
		v_g integer;
		v_b integer;
		v_a integer;
	begin
		v_r := floor(p_r * 255);
		v_g := floor(p_g * 255);
		v_b := floor(p_b * 255);
		v_a := floor(p_a * 255);

		if v_r < 0 then
			v_r := 0;
		elsif v_r > 255 then
			v_r := 255;
		end if;

		if v_g < 0 then
			v_g := 0;
		elsif v_g > 255 then
			v_g := 255;
		end if;

		if v_b < 0 then
			v_b := 0;
		elsif v_b > 255 then
			v_b := 255;
		end if;

		if v_a < 0 then
			v_a := 0;
		elsif v_a > 255 then
			v_a := 255;
		end if;

		return v_r * power(2, 24) + v_g * power(2, 16) + v_b * power(2, 8) + v_a;
	end;

	function geo_number_number_str(
		p_lat number,
		p_long number,
		p_info varchar2
	)
	return varchar2
	deterministic
	as
	begin
		if p_lat is null or p_long is null then
			return null;
		end if;
		if p_info is null then
			return repr_number(p_lat) || ', ' || repr_number(p_long);
		else
			return repr_number(p_lat) || ', ' || repr_number(p_long) || ', ' || p_info;
		end if;
	end;

	function attr_color_r(
		p_color integer
	)
	return integer
	deterministic
	as
	begin
		return bitand(p_color / power(2, 24), 255);
	end;

	function attr_color_g(
		p_color integer
	)
	return integer
	deterministic
	as
	begin
		return bitand(p_color / power(2, 16), 255);
	end;

	function attr_color_b(
		p_color integer
	)
	return integer
	deterministic
	as
	begin
		return bitand(p_color / power(2, 8), 255);
	end;

	function attr_color_a(
		p_color integer
	)
	return integer
	deterministic
	as
	begin
		return bitand(p_color, 255);
	end;

	function attr_geo_lat(
		p_geo varchar2
	)
	return number
	deterministic
	as
		v_lat number;
		v_long number;
		v_info varchar2(4000);
	begin
		geo_parse(p_geo, v_lat, v_long, v_info);
		return v_lat;
	end;

	function attr_geo_long(
		p_geo varchar2
	)
	return number
	deterministic
	as
		v_lat number;
		v_long number;
		v_info varchar2(4000);
	begin
		geo_parse(p_geo, v_lat, v_long, v_info);
		return v_long;
	end;

	function attr_geo_info(
		p_geo varchar2
	)
	return varchar2
	deterministic
	as
		v_lat number;
		v_long number;
		v_info varchar2(4000);
	begin
		geo_parse(p_geo, v_lat, v_long, v_info);
		return v_info;
	end;

	function attr_date_weekday(
		p_date date
	)
	return integer
	deterministic
	as
	begin
		return mod(trunc(p_date) - trunc(p_date, 'IW'), 7);
	end;

	function date_int(
		p_year in integer,
		p_month in integer,
		p_day in integer
	)
	return date
	deterministic
	as
	begin
		if p_year is null or p_year < 0 or p_year > 10000 then
			return null;
		elsif p_month is null or p_month < 0 or p_month > 12 then
			return null;
		elsif p_day is null or p_day < 0 or p_day > 31 then
			return null;
		else
			begin
				return to_date(lpad(p_year, 4, '0') || lpad(p_month, 2, '0') || lpad(p_day, 2, '0'), 'YYYYMMDD');
			exception when others then
				return null;
			end;
		end if;
	end;

	function datetime_int(
		p_year in integer,
		p_month in integer,
		p_day in integer,
		p_hour in integer := 0,
		p_minute in integer := 0,
		p_second in integer := 0
	)
	return date
	deterministic
	as
	begin
		if p_year is null or p_year < 0 or p_year > 10000 then
			return null;
		elsif p_month is null or p_month < 0 or p_month > 12 then
			return null;
		elsif p_day is null or p_day < 0 or p_day > 31 then
			return null;
		elsif p_hour is null or p_hour < 0 or p_hour > 24 then
			return null;
		elsif p_minute is null or p_minute < 0 or p_minute > 60 then
			return null;
		elsif p_second is null or p_second < 0 or p_second > 60 then
			return null;
		else
			begin
				return to_date(lpad(p_year, 4, '0') || lpad(p_month, 2, '0') || lpad(p_day, 2, '0') || lpad(p_hour, 2, '0') || lpad(p_minute, 2, '0') || lpad(p_second, 2, '0'), 'YYYYMMDDHH24MISS');
			exception when others then
				return null;
			end;
		end if;
	end;

	function len_intlist(
		p_list integers
	)
	return integer
	deterministic
	as
	begin
		if p_list is null then
			return null;
		else
			return p_list.count;
		end if;
	end;

	function len_numberlist(
		p_list numbers
	)
	return integer
	deterministic
	as
	begin
		if p_list is null then
			return null;
		else
			return p_list.count;
		end if;
	end;

	function len_strlist(
		p_list varchars
	)
	return integer
	deterministic
	as
	begin
		if p_list is null then
			return null;
		else
			return p_list.count;
		end if;
	end;

	function len_cloblist(
		p_list clobs
	)
	return integer
	deterministic
	as
	begin
		if p_list is null then
			return null;
		else
			return p_list.count;
		end if;
	end;

	function len_datetimelist(
		p_list dates
	)
	return integer
	deterministic
	as
	begin
		if p_list is null then
			return null;
		else
			return p_list.count;
		end if;
	end;

	function list_str(
		p_str varchar2
	)
	return varchars
	deterministic
	as
		v_result varchars := varchars();
	begin
		if p_str is not null then
			for i in 1 .. length(p_str) loop
				v_result.extend();
				v_result(v_result.count) := substr(p_str, i, 1);
			end loop;
		end if;
		return v_result;
	end;

	function list_clob(
		p_clob clob
	)
	return varchars
	deterministic
	as
		v_result varchars := varchars();
	begin
		if p_clob is not null then
			for i in 1 .. length(p_clob) loop
				v_result.extend();
				v_result(v_result.count) := substr(p_clob, i, 1);
			end loop;
		end if;
		return v_result;
	end;

	function set_str(
		p_str varchar2
	)
	return varchars
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set setdict;
		v_result varchars := varchars();
		v_key varchar2(1);
	begin
		if p_str is null then
			return v_result;
		end if;
		for i in 1 .. length(p_str) loop
			v_set(substr(p_str, i, 1)) := 1;
		end loop;
		v_key := v_set.first;
		while v_key is not null loop
			v_result.extend();
			v_result(v_result.count) := v_key;
			v_key := v_set.next(v_key);
		end loop;
		return v_result;
	end;

	function set_intlist(
		p_list integers
	)
	return integers
	deterministic
	as
		type setdict is table of integer index by varchar2(40);
		v_set setdict;
		v_result integers := integers();
		v_key varchar2(40);
		v_hasnull integer := 0;
	begin
		if p_list is null then
			return v_result;
		end if;
		for i in 1 .. p_list.count loop
			if p_list(i) is null then
				v_hasnull := 1;
			else
				v_set(p_list(i)) := 1;
			end if;
		end loop;
		v_key := v_set.first;
		while v_key is not null loop
			v_result.extend();
			v_result(v_result.count) := v_key;
			v_key := v_set.next(v_key);
		end loop;
		if v_hasnull = 1 then
			v_result.extend();
			v_result(v_result.count) := null;
		end if;
		return v_result;
	end;

	function set_numberlist(
		p_list numbers
	)
	return numbers
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set setdict;
		v_result numbers := numbers();
		v_key varchar2(100);
		v_hasnull integer := 0;
	begin
		if p_list is null then
			return v_result;
		end if;
		for i in 1 .. p_list.count loop
			if p_list(i) is null then
				v_hasnull := 1;
			else
				v_set(p_list(i)) := 1;
			end if;
		end loop;
		v_key := v_set.first;
		while v_key is not null loop
			v_result.extend();
			v_result(v_result.count) := v_key;
			v_key := v_set.next(v_key);
		end loop;
		if v_hasnull = 1 then
			v_result.extend();
			v_result(v_result.count) := null;
		end if;
		return v_result;
	end;

	function set_strlist(
		p_list varchars
	)
	return varchars
	deterministic
	as
		type setdict is table of integer index by varchar2(4000);
		v_set setdict;
		v_result varchars := varchars();
		v_key varchar2(4000);
		v_hasnull integer := 0;
	begin
		if p_list is null or p_list.count = 0 then
			return v_result;
		end if;
		for i in 1 .. p_list.count loop
			if p_list(i) is null then
				v_hasnull := 1;
			else
				v_set(p_list(i)) := 1;
			end if;
		end loop;
		v_key := v_set.first;
		while v_key is not null loop
			v_result.extend();
			v_result(v_result.count) := v_key;
			v_key := v_set.next(v_key);
		end loop;
		if v_hasnull = 1 then
			v_result.extend();
			v_result(v_result.count) := null;
		end if;
		return v_result;
	end;

	function set_datetimelist(
		p_list dates
	)
	return dates
	deterministic
	as
		type setdict is table of integer index by varchar2(100);
		v_set setdict;
		v_result dates := dates();
		v_key varchar2(100);
		v_hasnull integer := 0;
	begin
		if p_list is null then
			return v_result;
		end if;
		for i in 1 .. p_list.count loop
			if p_list(i) is null then
				v_hasnull := 1;
			else
				v_set(to_char(p_list(i), 'YYYY-MM-DD HH24:MI:SS')) := 1;
			end if;
		end loop;
		v_key := v_set.first;
		while v_key is not null loop
			v_result.extend();
			v_result(v_result.count) := to_date(v_key, 'YYYY-MM-DD HH24:MI:SS');
			v_key := v_set.next(v_key);
		end loop;
		if v_hasnull = 1 then
			v_result.extend();
			v_result(v_result.count) := null;
		end if;
		return v_result;
	end;

	function dist_geo_geo(
		p_geo1 varchar2,
		p_geo2 varchar2
	)
	return number
	deterministic
	as
		-- distance between two geo coordinates (see https://de.wikipedia.org/wiki/Orthodrome#Genauere_Formel_zur_Abstandsberechnung_auf_der_Erde)

		v_lat1 number(15, 12);
		v_long1 number(15, 12);
		v_info1 varchar2(4000);
		v_lat2 number(15, 12);
		v_long2 number(15, 12);
		v_info2 varchar2(4000);

		v_deg2rad constant number := 3.14159265358979/180; -- Conversion factor degree -> radians
		v_radius constant number := 6378.137; -- Equatorial radius of earth in km
		v_flat constant number := 1/298.257223563; -- Earth flattening

		v_f number;
		v_g number;
		v_l number;
		v_s number;
		v_c number;
		v_w number;
		v_t number;
		v_h1 number;
		v_h2 number;
		v_dist number;

		function sqsin(p_x number)
		return number
		as
			v_x number;
		begin
			v_x := sin(p_x);
			return v_x * v_x;
		end;

		function sqcos(p_x number)
		return number
		as
			v_x number;
		begin
			v_x := cos(p_x);
			return v_x * v_x;
		end;
	begin
		geo_parse(p_geo1, v_lat1, v_long1, v_info1);
		geo_parse(p_geo2, v_lat2, v_long2, v_info2);
		if v_lat1 is null or v_long1 is null or v_lat2 is null or v_long2 is null then
			return null;
		else
			v_lat1 := v_lat1 * v_deg2rad;
			v_long1 := v_long1 * v_deg2rad;
			v_lat2 := v_lat2 * v_deg2rad;
			v_long2 := v_long2 * v_deg2rad;

			v_f := (v_lat1 + v_lat2)/2;
			v_g := (v_lat1 - v_lat2)/2;
			v_l := (v_long1 - v_long2)/2;

			v_s := sqsin(v_g) * sqcos(v_l) + sqcos(v_f) * sqsin(v_l);
			v_c := sqcos(v_g) * sqcos(v_l) + sqsin(v_f) * sqsin(v_l);

			v_w := atan(sqrt(v_s/v_c));
			v_dist := 2 * v_w * v_radius;

			if v_w != 0 then
				v_t := sqrt(v_s * v_c)/v_w;
				v_h1 := (3*v_t-1)/(2*v_c);
				v_h2 := (3*v_t+1)/(2*v_s);
				v_dist := v_dist * (1 + v_flat * v_h1 * sqsin(v_f) * sqcos(v_g) - v_flat * v_h2 * sqcos(v_f) * sqsin(v_g));
			end if;

			return v_dist;
		end if;
	end;

	function startswith_clob_str(
		p_haystack clob,
		p_prefix varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_prefix is null or p_prefix = dbms_lob.substr(p_haystack, length(p_prefix), 1) then
			return 1;
		else
			return 0;
		end if;
	end;

	function startswith_clob_strlist(
		p_haystack clob,
		p_prefixes varchars
	)
	return integer
	deterministic
	as
	begin
		for i in 1 .. p_prefixes.count loop
			if startswith_clob_str(p_haystack, p_prefixes(i)) = 1 then
				return 1;
			end if;
		end loop;
		return 0;
	end;

	function startswith_str_str(
		p_haystack varchar2,
		p_prefix varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_prefix is null or p_prefix = substr(p_haystack, 1, length(p_prefix)) then
			return 1;
		end if;
		return 0;
	end;

	function startswith_str_strlist(
		p_haystack varchar2,
		p_prefixes varchars
	)
	return integer
	deterministic
	as
	begin
		for i in 1 .. p_prefixes.count loop
			if startswith_str_str(p_haystack, p_prefixes(i)) = 1 then
				return 1;
			end if;
		end loop;
		return 0;
	end;

	function endswith_clob_str(
		p_haystack clob,
		p_suffix varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_suffix is null or p_suffix = dbms_lob.substr(p_haystack, length(p_suffix), dbms_lob.getlength(p_haystack) - length(p_suffix) + 1) then
			return 1;
		else
			return 0;
		end if;
	end;

	function endswith_clob_strlist(
		p_haystack clob,
		p_suffixes varchars
	)
	return integer
	deterministic
	as
	begin
		for i in 1 .. p_suffixes.count loop
			if endswith_clob_str(p_haystack, p_suffixes(i)) = 1 then
				return 1;
			end if;
		end loop;
		return 0;
	end;

	function endswith_str_str(
		p_haystack varchar2,
		p_suffix varchar2
	)
	return integer
	deterministic
	as
	begin
		if p_suffix is null or p_suffix = substr(p_haystack, length(p_haystack) - length(p_suffix) + 1, length(p_suffix)) then
			return 1;
		else
			return 0;
		end if;
	end;

	function endswith_str_strlist(
		p_haystack varchar2,
		p_suffixes varchars
	)
	return integer
	deterministic
	as
	begin
		for i in 1 .. p_suffixes.count loop
			if endswith_str_str(p_haystack, p_suffixes(i)) = 1 then
				return 1;
			end if;
		end loop;
		return 0;
	end;

	function strip_clob(
		p_clob in clob,
		p_strip in varchar2,
		p_lstrip in integer,
		p_rstrip in integer
	)
	return clob
	deterministic
	as
		v_strip varchar2(1000);
		v_chrs integers := new integers(9, 10, 11, 12, 13, 28, 29, 30, 31, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288);
		v_from integer := 1;
		v_to integer := dbms_lob.getlength(p_clob);
		v_clob clob;
		v_i integer;
		v_size integer;
	begin
		if p_clob is null then
			return null;
		end if;
		if p_strip is null then
			for i in 1 .. v_chrs.count loop
				if v_chrs(i) > 256 then
					exit;
				end if;
				v_strip := v_strip || chr(v_chrs(i));
			end loop;
		else
			v_strip := p_strip;
		end if;
		if p_lstrip = 1 then
			for i in 1 .. v_to loop
				if instr(v_strip, dbms_lob.substr(p_clob, 1, i)) = 0 then
					v_from := i;
					exit;
				end if;
			end loop;
		end if;
		if p_rstrip = 1 then
			for i in 1 .. v_to loop
				if instr(v_strip, dbms_lob.substr(p_clob, 1, v_to + 1 - i)) = 0 then
					v_to := v_to - i + 1;
					exit;
				end if;
			end loop;
		end if;

		dbms_lob.createtemporary(v_clob, true);
		v_size := v_to - v_from + 1;
		v_i := 1;
		while v_i * 32000 < v_size loop
			dbms_lob.writeappend(v_clob, 32000, dbms_lob.substr(p_clob, 32000, v_from + (v_i-1) * 32000));
			v_i := v_i + 1;
		end loop;
		dbms_lob.writeappend(v_clob, v_to - v_from + 1 - (v_i-1) * 32000, dbms_lob.substr(p_clob, v_to - v_from + 1 - (v_i-1) * 32000, v_from + (v_i-1) * 32000));
		return v_clob;
	end;

	function strip_str(
		p_str in varchar2,
		p_strip in varchar2,
		p_lstrip in integer,
		p_rstrip in integer
	)
	return varchar2
	deterministic
	as
		v_from integer := 1;
		v_to integer := length(p_str);
	begin
		if p_str is null then
			return null;
		end if;
		if p_strip is null then
			if p_lstrip = 1 then
				if p_rstrip = 1 then
					return regexp_replace(regexp_replace(p_str, '^\s+', ''), '\s+$', '');
				else
					return regexp_replace(p_str, '^\s+', '');
				end if;
			else
				return regexp_replace(p_str, '\s+$', '');
			end if;
		else
			if p_lstrip = 1 then
				for i in 1 .. v_to loop
					if instr(p_strip, substr(p_str, i, 1)) = 0 then
						v_from := i;
						exit;
					end if;
				end loop;
			end if;
			if p_rstrip = 1 then
				for i in 1 .. v_to loop
					if instr(p_strip, substr(p_str, v_to + 1 - i, 1)) = 0 then
						v_to := v_to - i + 1;
						exit;
					end if;
				end loop;
			end if;
			return substr(p_str, v_from, v_to - v_from + 1);
		end if;
	end;

	function find_str_str(
		p_haystack in varchar2,
		p_needle in varchar2,
		p_start in integer,
		p_stop in integer
	)
	return integer
	deterministic
	as
		v_start integer;
		v_stop integer;
		v_pos integer;
	begin
		if p_haystack is null then
			return -1;
		elsif p_needle is null then
			return 0;
		else
			v_start := slice_start(p_start, length(p_haystack));
			v_stop := slice_stop(p_stop, length(p_haystack));
			v_pos := instr(p_haystack, p_needle, v_start+1)-1;
			if v_pos = -1 then
				return -1;
			elsif v_pos + length(p_needle) > v_stop then
				return -1;
			else
				return v_pos;
			end if;
		end if;
	end;

	function find_str_clob(
		p_haystack in varchar2,
		p_needle in clob,
		p_start in integer,
		p_stop in integer
	)
	return integer
	deterministic
	as
		v_start integer;
		v_stop integer;
		v_pos integer;
	begin
		if p_haystack is null or length(p_haystack) = 0 then
			return -1;
		elsif p_needle is null then
			return 0;
		else
			v_start := slice_start(p_start, length(p_haystack));
			v_stop := slice_stop(p_stop, length(p_haystack));
			v_pos := instr(p_haystack, p_needle, v_start+1)-1;
			if v_pos = -1 then
				return -1;
			elsif v_pos + length(p_needle) > v_stop then
				return -1;
			else
				return v_pos;
			end if;
		end if;
	end;

	function find_clob_str(
		p_haystack in clob,
		p_needle in varchar2,
		p_start in integer,
		p_stop in integer
	)
	return integer
	deterministic
	as
		v_start integer;
		v_stop integer;
		v_pos integer;
	begin
		if p_haystack is null or length(p_haystack) = 0 then
			return -1;
		elsif p_needle is null then
			return 0;
		else
			v_start := slice_start(p_start, length(p_haystack));
			v_stop := slice_stop(p_stop, length(p_haystack));
			v_pos := instr(p_haystack, p_needle, v_start+1)-1;
			if v_pos = -1 then
				return -1;
			elsif v_pos + length(p_needle) > v_stop then
				return -1;
			else
				return v_pos;
			end if;
		end if;
	end;

	function find_clob_clob(
		p_haystack in clob,
		p_needle in clob,
		p_start in integer,
		p_stop in integer
	)
	return integer
	deterministic
	as
		v_start integer;
		v_stop integer;
		v_pos integer;
	begin
		if p_haystack is null or length(p_haystack) = 0 then
			return -1;
		elsif p_needle is null or length(p_needle) = 0 then
			return 0;
		else
			v_start := slice_start(p_start, length(p_haystack));
			v_stop := slice_stop(p_stop, length(p_haystack));
			v_pos := instr(p_haystack, p_needle, v_start+1)-1;
			if v_pos = -1 then
				return -1;
			elsif v_pos + length(p_needle) > v_stop then
				return -1;
			else
				return v_pos;
			end if;
		end if;
	end;

	function split_str_str(
		p_string in varchar2,
		p_separator in varchar2,
		p_maxsplit in integer := null
	)
	return varchars
	deterministic
	as
		v_string varchar2(32767);
		v_from integer;
		v_to integer := 1;
		v_result varchars := varchars();
		v_restsplits integer := p_maxsplit;
	begin
		if p_string is not null then
			if p_separator is null then
				v_string := regexp_replace(regexp_replace(p_string, '^\s+', ''), '\s+$', '');
			else
				v_string := p_string;
			end if;
			loop
				v_from := v_to;
				if p_separator is null then
					v_to := regexp_instr(v_string, '\s+', v_from);
				else
					v_to := instr(v_string, p_separator, v_from);
				end if;
				if v_to = 0 or (v_restsplits is not null and v_restsplits <= 0) then
					v_to := length(v_string)+1;
				end if;
				v_result.extend();
				v_result(v_result.last()) := substr(v_string, v_from, v_to-v_from);
				if v_to = length(v_string)+1 then
					return v_result;
				end if;
				if p_separator is null then
					v_to := regexp_instr(v_string, '\s+', v_from, 1, 1);
				else
					v_to := v_to + length(p_separator);
				end if;
				if v_restsplits is not null then
					v_restsplits := v_restsplits - 1;
				end if;
			end loop;
		end if;
		return v_result;
	end;

	function split_clob_str(
		p_string in clob,
		p_separator in varchar2,
		p_maxsplit in integer := null
	)
	return clobs
	deterministic
	as
		v_string clob;
		v_from integer;
		v_to integer := 1;
		v_result clobs := clobs();
		v_restsplits integer := p_maxsplit;
	begin
		if p_string is not null and length(p_string) > 0 then
			if p_separator is null then
				v_string := regexp_replace(regexp_replace(p_string, '^\s+', ''), '\s+$', '');
			else
				v_string := p_string;
			end if;
			loop
				v_from := v_to;
				if p_separator is null then
					v_to := regexp_instr(v_string, '\s+', v_from);
				else
					v_to := instr(v_string, p_separator, v_from);
				end if;
				if v_to = 0 and (v_restsplits is null or v_restsplits <= 0) then
					v_to := length(v_string)+1;
				end if;
				v_result.extend();
				v_result(v_result.last()) := dbms_lob.substr(v_string, v_to-v_from, v_from);
				if v_to = length(v_string)+1 then
					return v_result;
				end if;
				if p_separator is null then
					v_to := regexp_instr(v_string, '\s+', v_from, 1, 1);
				else
					v_to := v_to + length(p_separator);
				end if;
				if v_restsplits is not null then
					v_restsplits := v_restsplits - 1;
				end if;
			end loop;
		end if;
		return v_result;
	end;

	function join_str_str(
		p_separator in varchar2,
		p_list in varchar2
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_separator is null then
			return p_list;
		elsif p_list is null then
			return null;
		else
			for i in 1..length(p_list) loop
				if i != 1 then
					v_result := v_result || p_separator;
				end if;
				v_result := v_result || substr(p_list, i, 1);
			end loop;
			return v_result;
		end if;
	end;

	function join_str_strlist(
		p_separator in varchar2,
		p_list in varchars
	)
	return varchar2
	deterministic
	as
		v_result varchar2(32000);
	begin
		if p_list is null then
			return null;
		else
			for i in 1..p_list.count loop
				if i != 1 then
					v_result := v_result || p_separator;
				end if;
				v_result := v_result || p_list(i);
			end loop;
			return v_result;
		end if;
	end;

	function join_str_clob(
		p_separator in varchar2,
		p_list in clob
	)
	return clob
	deterministic
	as
		v_result clob;
	begin
		if p_separator is null then
			return p_list;
		elsif p_list is null then
			return null;
		else
			dbms_lob.createtemporary(v_result, true);
			for i in 1..length(p_list) loop
				if i != 1 then
					dbms_lob.writeappend(v_result, length(p_separator), p_separator);
				end if;
				dbms_lob.writeappend(v_result, 1, dbms_lob.substr(p_list, 1, i));
			end loop;
			return v_result;
		end if;
	end;

	function join_str_cloblist(
		p_separator in varchar2,
		p_list in clobs
	)
	return clob
	deterministic
	as
		v_result clob;
	begin
		if p_list is null then
			return null;
		else
			dbms_lob.createtemporary(v_result, true);
			for i in 1..p_list.count loop
				if i != 1 then
					dbms_lob.writeappend(v_result, length(p_separator), p_separator);
				end if;
				dbms_lob.append(v_result, p_list(i));
			end loop;
			return v_result;
		end if;
	end;

	function lum(
		p_color integer
	)
	return number
	deterministic
	as
		v_r integer;
		v_g integer;
		v_b integer;
		v_maxc integer;
		v_minc integer;
	begin
		v_r := attr_color_r(p_color);
		v_g := attr_color_g(p_color);
		v_b := attr_color_b(p_color);

		v_minc := least(v_r, v_g, v_b);
		v_maxc := greatest(v_r, v_g, v_b);
		return (v_minc + v_maxc)/255/2;
	end;

	function intlist_fromlen(p_len integer)
	return integers
	deterministic
	as
		v_result integers;
	begin
		v_result := integers();
		for i in 1..p_len loop
			v_result.extend;
		end loop;
		return v_result;
	end;

	function numberlist_fromlen(p_len integer)
	return numbers
	deterministic
	as
		v_result numbers;
	begin
		v_result := numbers();
		for i in 1..p_len loop
			v_result.extend;
		end loop;
		return v_result;
	end;

	function strlist_fromlen(p_len integer)
	return varchars
	deterministic
	as
		v_result varchars;
	begin
		v_result := varchars();
		for i in 1..p_len loop
			v_result.extend;
		end loop;
		return v_result;
	end;

	function cloblist_fromlen(p_len integer)
	return clobs
	deterministic
	as
		v_result clobs;
	begin
		v_result := clobs();
		for i in 1..p_len loop
			v_result.extend;
		end loop;
		return v_result;
	end;

	function datetimelist_fromlen(p_len integer)
	return dates
	deterministic
	as
		v_result dates;
	begin
		v_result := dates();
		for i in 1..p_len loop
			v_result.extend;
		end loop;
		return v_result;
	end;
end;

/

